"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapSetNooks_NooksEntry = exports.MapSetNooks = exports.MapSetSpaces = exports.MapSetSprites = exports.MapSetForegroundImagePath = exports.MapSetBackgroundImagePath = exports.MapSetCollisionsBits = exports.MapSetCollisions = exports.MapSetDimensions = exports.DBDesk = exports.WireArea = exports.AreaPosition = exports.Asset = exports.Announcer = exports.Portal = exports.SpawnPoint = exports.WirePoint = exports.NookDiff = exports.RecordingInfo = exports.RequestedUsers_UsersEntry = exports.RequestedUsers = exports.RequestUser = exports.AllowedUsers = exports.NookCoords = exports.Space = exports.ObjectTime = exports.Sound = exports.MapAndDesk = exports.DeskInfoV2 = exports.DeskInfo = exports.DeskObjects_ObjectsEntry = exports.DeskObjects = exports.BackedUpDeskObject = exports.SpaceMemberInfo_RolesEntry = exports.SpaceMemberInfo = exports.WireObject = exports.WireObjectSpritesheet_AnimationsEntry = exports.WireObjectSpritesheet = exports.WireObjectSpriteAnimConfig = exports.WireObjectSpritesheetFraming = exports.DBOutfit = exports.PlayerInitInfo = exports.InteractionEnum = exports.MoveDirectionEnum = exports.SpriteDirectionEnum = exports.RespondToAccessRequest_LocationTypeEnum = exports.InteractionEnum_ENUM = exports.MoveDirectionEnum_ENUM = exports.SpriteDirectionEnum_ENUM = exports.protobufPackage = void 0;
exports.PlayerMoves = exports.GotRequestMute = exports.PlayerJoins = exports.TransactionStatus = exports.Ready = exports.ErrorEvent = exports.Warn = exports.Info = exports.ServerHeartbeat = exports.SubscriptionsUpdated = exports.ServerClientEvent = exports.ServerClientBatch = exports.EnterWithTeammatesHostInitiatesEnterSpace = exports.EnterWithTeammatesLobbyStateUpdated = exports.EnterWithTeammatesLobbyUser = exports.MapLocation = exports.ItemAbility = exports.SpaceItem_AbilitiesEntry = exports.SpaceItem_MetaEntry = exports.SpaceItem = exports.InventoryItem = exports.Inventory_OrderEntry = exports.Inventory_ItemsEntry = exports.Inventory = exports.MapSetScript = exports.TutorialTaskMapArea = exports.WireTutorialTasks = exports.MapSetTutorialTasks = exports.MapSetDecoration = exports.MapSetDescription = exports.MapSetEnabledChats = exports.MapSetMiniMapImagePath = exports.MapDeleteObjectById = exports.MapDeleteObject = exports.MapSetAreas_AreasEntry = exports.MapSetAreas = exports.MapSetFloors_FloorsEntry = exports.MapSetFloors = exports.MapSetWalls_WallsEntry = exports.MapSetWalls = exports.MapSetUseDrawnBG = exports.MapSetMuteOnEntry = exports.MapSetName = exports.MapSetObjects_ObjectsEntry = exports.MapSetObjects = exports.MapSetAssets = exports.MapSetAnnouncer = exports.MapSetPortals = exports.MapSetSpawns = exports.MapSetSpawn = void 0;
exports.PlayerSetsCurrentDesk = exports.PlayerSetsInConversation = exports.PlayerSetsEventStatus = exports.PlayerShootsConfetti = exports.SpaceSetsIdMapping = exports.CookieFound = exports.PlayerEntersPortal = exports.SpaceIsClosed = exports.SpaceSetsSpaceMembers_MembersEntry = exports.SpaceSetsSpaceMembers = exports.DynamicGates = exports.DynamicGate = exports.SpaceOverwrites = exports.RespawnComplete = exports.PlayerSetsIsSignedIn = exports.PlayerSetsOutfitString = exports.PlayerExits = exports.PlayerSetsAffiliation = exports.PlayerSetsEmojiStatus = exports.PlayerSetsIsMobile = exports.PlayerSetsPersonalImageUrl = exports.PlayerSetsProfileImageUrl = exports.PlayerSetsDescription = exports.PlayerSetsPhone = exports.PlayerSetsTimezone = exports.PlayerSetsStartDate = exports.PlayerSetsCountry = exports.PlayerSetsCity = exports.PlayerSetsTitle = exports.PlayerSetsPronouns = exports.PlayerSetsTextStatus = exports.PlayerSetsName = exports.PlayerSetsLastActive = exports.PlayerSetsWorkCondition = exports.PlayerSetsEmoteV2 = exports.PlayerActivelySpeaks = exports.PlayerLeavesWhisper = exports.PlayerEntersWhisperV2 = exports.PlayerEntersWhisper = exports.PlayerGhosts = exports.PlayerInteracts = exports.Timestamp = exports.PlayerWaves = exports.PlayerChats = exports.SetScreenPointerServer = exports.PlayerSetsImagePointer = exports.PlayerRings = exports.PlayerSpotlights = exports.PlayerSetsAvailability = exports.PlayerSetsStatus = void 0;
exports.SpaceRolePermissionOverrideUpdated = exports.SetDeskFromNextAvailableDesk = exports.EnterWithTeammatesInitiateEnterSpace = exports.EnterWithTeammatesSetOwnLobbyInfo = exports.SpaceSetsGuestPassStatuses = exports.PlayerGuestPassStatus = exports.AccessRequestRespondedTo = exports.AccessRequestsUpdated = exports.AccessRequest = exports.PlayerStartsRecording = exports.PlayerSetsAway = exports.SpaceOverCapacityDeniesUser = exports.SpaceSetsCapacity = exports.PlayerSetsDeskInfo = exports.PrecomputedEnterLocation = exports.PlayerSetsAllowScreenPointer = exports.PlayerTriggersInventoryItem = exports.SpaceUpdatesItems_ItemsEntry = exports.SpaceUpdatesItems = exports.PlayerUpdatesInventory_OrderEntry = exports.PlayerUpdatesInventory_ItemsEntry = exports.PlayerUpdatesInventory = exports.SpaceRegistersCommand = exports.PlayerSendsCommand = exports.PlayerHighFives = exports.FXShakeCamera = exports.FXShakeObject = exports.PlayerEditsChatMessage = exports.MapMoveObject = exports.PlayerCrafts_InputsEntry = exports.PlayerCrafts = exports.PlayerSetsSubtitle = exports.PlayerSetsIsNpc = exports.PlayerSetsManualVideoSrc = exports.PlayerRequestsToLead = exports.PlayerSetsFollowTarget = exports.PlayerNotifies = exports.PlayerTriggersItem = exports.PlayerSetsItemString = exports.PlayerUpdatesFocusModeStatus = exports.CustomEvent = exports.PlayerBlocks = exports.PlayerSetsFocusModeEndTime = exports.SpaceStopsSound = exports.SpacePlaysSound = exports.PlayerSetsIsAlone = exports.PlayerSetsSpeedModifier = exports.PlayerSetsVehicleId = exports.PlayerSetsGoKartId = exports.PlayerSetsCurrentArea = void 0;
exports.RespawnAtDesk = exports.Respawn = exports.Spawn = exports.SetWorkCondition = exports.Teleport = exports.SetEmojiStatus = exports.PrecomputeEnter = exports.Enter = exports.Exit = exports.SetPersonalImageUrl = exports.SetProfileImageUrl = exports.SetDescription = exports.SetPhone = exports.SetTimezone = exports.SetStartDate = exports.SetCountry = exports.SetCity = exports.SetTitle = exports.SetPronouns = exports.SetTextStatus = exports.SetName = exports.SetEmoteV2 = exports.Ghost = exports.LeaveWhisper = exports.EnterWhisper = exports.ActivelySpeaking = exports.Interact = exports.Notify = exports.Chat = exports.SetImpassable = exports.Block = exports.Kick = exports.Ban = exports.SetScreenPointer = exports.SetImagePointer = exports.Ring = exports.Spotlight = exports.SetOutfitString = exports.SetAvailability = exports.SetStatus = exports.SetAffiliation = exports.RequestMute = exports.Move = exports.UpdateSubscriptions_MapUpdateIdsEntry = exports.UpdateSubscriptions_SubscriptionsEntry = exports.UpdateSubscriptions = exports.ClientBackupHeartbeat = exports.ClientHeartbeat = exports.ClientServerAction = exports.ClientServerBatch = void 0;
exports.protobufWriterLibrary = exports.SetSpaceRolePermissionOverride = exports.RespondToAccessRequest = exports.RequestAccessViaCheckIn = exports.StartRecording = exports.SetAway = exports.Wave = exports.SetDeskInfo = exports.SetAllowScreenPointer = exports.TriggerInventoryItem = exports.HipToBeSquare = exports.RemoveInventoryItem = exports.AddInventoryItem = exports.HighFive = exports.Craft_InputsEntry = exports.Craft = exports.RegisterCommand = exports.SendCommand = exports.ChatMessageUpdated = exports.ChatReply = exports.SpeakerUpdatesSession = exports.PlayerUpdatesSession = exports.MapCommitsChanges = exports.SetSubtitle = exports.SetManualVideoSrc = exports.EnterPortal = exports.RequestToLead = exports.SetFollowTarget = exports.CustomAction = exports.TriggerItem = exports.SetItemString = exports.SetFocusModeEndTime = exports.StopSound = exports.PlaySound = exports.SetIsMobile = exports.SetIsAlone = exports.SetSpeedModifier = exports.SetVehicleId = exports.SetGoKartId = exports.SetCurrentArea = exports.SetCurrentDesk = exports.SetInConversation = exports.SetEventStatus = exports.ShootConfetti = exports.MapAddObject = exports.Init = exports.UpdateNookPermission = exports.RequestToJoinNook = void 0;
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "";
var SpriteDirectionEnum_ENUM;
(function (SpriteDirectionEnum_ENUM) {
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Stand"] = 0] = "Stand";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Down"] = 1] = "Down";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["DownAlt"] = 2] = "DownAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Up"] = 3] = "Up";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["UpAlt"] = 4] = "UpAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Left"] = 5] = "Left";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["LeftAlt"] = 6] = "LeftAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Right"] = 7] = "Right";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["RightAlt"] = 8] = "RightAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance1"] = 9] = "Dance1";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance2"] = 10] = "Dance2";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance3"] = 11] = "Dance3";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance4"] = 12] = "Dance4";
})(SpriteDirectionEnum_ENUM = exports.SpriteDirectionEnum_ENUM || (exports.SpriteDirectionEnum_ENUM = {}));
var MoveDirectionEnum_ENUM;
(function (MoveDirectionEnum_ENUM) {
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Left"] = 0] = "Left";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Right"] = 1] = "Right";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Up"] = 2] = "Up";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Down"] = 3] = "Down";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Dance"] = 4] = "Dance";
})(MoveDirectionEnum_ENUM = exports.MoveDirectionEnum_ENUM || (exports.MoveDirectionEnum_ENUM = {}));
var InteractionEnum_ENUM;
(function (InteractionEnum_ENUM) {
    InteractionEnum_ENUM[InteractionEnum_ENUM["NONE"] = 0] = "NONE";
    InteractionEnum_ENUM[InteractionEnum_ENUM["EMBEDDED_WEBSITE"] = 1] = "EMBEDDED_WEBSITE";
    InteractionEnum_ENUM[InteractionEnum_ENUM["POSTER"] = 2] = "POSTER";
    InteractionEnum_ENUM[InteractionEnum_ENUM["VIDEO"] = 3] = "VIDEO";
    InteractionEnum_ENUM[InteractionEnum_ENUM["EXTERNAL_CALL"] = 4] = "EXTERNAL_CALL";
    InteractionEnum_ENUM[InteractionEnum_ENUM["EXTENSION"] = 5] = "EXTENSION";
    InteractionEnum_ENUM[InteractionEnum_ENUM["NOTE"] = 6] = "NOTE";
    InteractionEnum_ENUM[InteractionEnum_ENUM["MODAL_EXTENSION"] = 7] = "MODAL_EXTENSION";
    InteractionEnum_ENUM[InteractionEnum_ENUM["COMPONENT_MODAL"] = 8] = "COMPONENT_MODAL";
    InteractionEnum_ENUM[InteractionEnum_ENUM["SIDE_PANEL_TRIGGER"] = 9] = "SIDE_PANEL_TRIGGER";
})(InteractionEnum_ENUM = exports.InteractionEnum_ENUM || (exports.InteractionEnum_ENUM = {}));
var RespondToAccessRequest_LocationTypeEnum;
(function (RespondToAccessRequest_LocationTypeEnum) {
    RespondToAccessRequest_LocationTypeEnum[RespondToAccessRequest_LocationTypeEnum["MyLocation"] = 0] = "MyLocation";
    RespondToAccessRequest_LocationTypeEnum[RespondToAccessRequest_LocationTypeEnum["DefaultSpawn"] = 1] = "DefaultSpawn";
})(RespondToAccessRequest_LocationTypeEnum = exports.RespondToAccessRequest_LocationTypeEnum || (exports.RespondToAccessRequest_LocationTypeEnum = {}));
function createBaseSpriteDirectionEnum() {
    return {};
}
exports.SpriteDirectionEnum = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpriteDirectionEnum();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMoveDirectionEnum() {
    return {};
}
exports.MoveDirectionEnum = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMoveDirectionEnum();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInteractionEnum() {
    return {};
}
exports.InteractionEnum = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInteractionEnum();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerInitInfo() {
    return {};
}
exports.PlayerInitInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== undefined) {
            writer.uint32(10).string(message.name);
        }
        if (message.x !== undefined) {
            writer.uint32(24).uint32(message.x);
        }
        if (message.y !== undefined) {
            writer.uint32(32).uint32(message.y);
        }
        if (message.map !== undefined) {
            writer.uint32(42).string(message.map);
        }
        if (message.affiliation !== undefined) {
            writer.uint32(50).string(message.affiliation);
        }
        if (message.busy !== undefined) {
            writer.uint32(56).bool(message.busy);
        }
        if (message.textStatus !== undefined) {
            writer.uint32(66).string(message.textStatus);
        }
        if (message.emojiStatus !== undefined) {
            writer.uint32(74).string(message.emojiStatus);
        }
        if (message.currentlyEquippedWearables !== undefined) {
            exports.DBOutfit.encode(message.currentlyEquippedWearables, writer.uint32(82).fork()).ldelim();
        }
        if (message.focusModeEndTime !== undefined) {
            writer.uint32(90).string(message.focusModeEndTime);
        }
        if (message.currentDesk !== undefined) {
            writer.uint32(106).string(message.currentDesk);
        }
        if (message.itemString !== undefined) {
            writer.uint32(114).string(message.itemString);
        }
        if (message.isNpc !== undefined) {
            writer.uint32(120).bool(message.isNpc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerInitInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 3:
                    message.x = reader.uint32();
                    break;
                case 4:
                    message.y = reader.uint32();
                    break;
                case 5:
                    message.map = reader.string();
                    break;
                case 6:
                    message.affiliation = reader.string();
                    break;
                case 7:
                    message.busy = reader.bool();
                    break;
                case 8:
                    message.textStatus = reader.string();
                    break;
                case 9:
                    message.emojiStatus = reader.string();
                    break;
                case 10:
                    message.currentlyEquippedWearables = exports.DBOutfit.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.focusModeEndTime = reader.string();
                    break;
                case 13:
                    message.currentDesk = reader.string();
                    break;
                case 14:
                    message.itemString = reader.string();
                    break;
                case 15:
                    message.isNpc = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDBOutfit() {
    return { skin: "", hair: "", facial_hair: "", top: "", bottom: "", shoes: "", hat: "", glasses: "", other: "" };
}
exports.DBOutfit = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.skin !== "") {
            writer.uint32(10).string(message.skin);
        }
        if (message.hair !== "") {
            writer.uint32(18).string(message.hair);
        }
        if (message.facial_hair !== "") {
            writer.uint32(26).string(message.facial_hair);
        }
        if (message.top !== "") {
            writer.uint32(34).string(message.top);
        }
        if (message.bottom !== "") {
            writer.uint32(42).string(message.bottom);
        }
        if (message.shoes !== "") {
            writer.uint32(50).string(message.shoes);
        }
        if (message.hat !== "") {
            writer.uint32(58).string(message.hat);
        }
        if (message.glasses !== "") {
            writer.uint32(66).string(message.glasses);
        }
        if (message.other !== "") {
            writer.uint32(74).string(message.other);
        }
        if (message.costume !== undefined) {
            writer.uint32(82).string(message.costume);
        }
        if (message.mobility !== undefined) {
            writer.uint32(90).string(message.mobility);
        }
        if (message.jacket !== undefined) {
            writer.uint32(98).string(message.jacket);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDBOutfit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.skin = reader.string();
                    break;
                case 2:
                    message.hair = reader.string();
                    break;
                case 3:
                    message.facial_hair = reader.string();
                    break;
                case 4:
                    message.top = reader.string();
                    break;
                case 5:
                    message.bottom = reader.string();
                    break;
                case 6:
                    message.shoes = reader.string();
                    break;
                case 7:
                    message.hat = reader.string();
                    break;
                case 8:
                    message.glasses = reader.string();
                    break;
                case 9:
                    message.other = reader.string();
                    break;
                case 10:
                    message.costume = reader.string();
                    break;
                case 11:
                    message.mobility = reader.string();
                    break;
                case 12:
                    message.jacket = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWireObjectSpritesheetFraming() {
    return { frameWidth: 0, frameHeight: 0 };
}
exports.WireObjectSpritesheetFraming = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.frameWidth !== 0) {
            writer.uint32(8).int32(message.frameWidth);
        }
        if (message.frameHeight !== 0) {
            writer.uint32(16).int32(message.frameHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWireObjectSpritesheetFraming();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.frameWidth = reader.int32();
                    break;
                case 2:
                    message.frameHeight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWireObjectSpriteAnimConfig() {
    return { sequence: [], frameRate: 0 };
}
exports.WireObjectSpriteAnimConfig = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.useSequenceAsRange !== undefined) {
            writer.uint32(8).bool(message.useSequenceAsRange);
        }
        writer.uint32(18).fork();
        for (const v of message.sequence) {
            writer.uint32(v);
        }
        writer.ldelim();
        if (message.loop !== undefined) {
            writer.uint32(24).bool(message.loop);
        }
        if (message.frameRate !== 0) {
            writer.uint32(32).uint32(message.frameRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWireObjectSpriteAnimConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.useSequenceAsRange = reader.bool();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.sequence.push(reader.uint32());
                        }
                    }
                    else {
                        message.sequence.push(reader.uint32());
                    }
                    break;
                case 3:
                    message.loop = reader.bool();
                    break;
                case 4:
                    message.frameRate = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWireObjectSpritesheet() {
    return { spritesheetUrl: "", framing: undefined, animations: {} };
}
exports.WireObjectSpritesheet = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spritesheetUrl !== "") {
            writer.uint32(10).string(message.spritesheetUrl);
        }
        if (message.framing !== undefined) {
            exports.WireObjectSpritesheetFraming.encode(message.framing, writer.uint32(18).fork()).ldelim();
        }
        Object.entries(message.animations).forEach(([key, value]) => {
            exports.WireObjectSpritesheet_AnimationsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.currentAnim !== undefined) {
            writer.uint32(34).string(message.currentAnim);
        }
        if (message.pauseAnimationsIfFpsBelowFramerate !== undefined) {
            writer.uint32(40).bool(message.pauseAnimationsIfFpsBelowFramerate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWireObjectSpritesheet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spritesheetUrl = reader.string();
                    break;
                case 2:
                    message.framing = exports.WireObjectSpritesheetFraming.decode(reader, reader.uint32());
                    break;
                case 3:
                    const entry3 = exports.WireObjectSpritesheet_AnimationsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.animations[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.currentAnim = reader.string();
                    break;
                case 5:
                    message.pauseAnimationsIfFpsBelowFramerate = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWireObjectSpritesheet_AnimationsEntry() {
    return { key: "", value: undefined };
}
exports.WireObjectSpritesheet_AnimationsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.WireObjectSpriteAnimConfig.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWireObjectSpritesheet_AnimationsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.WireObjectSpriteAnimConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWireObject() {
    return { _tags: [] };
}
exports.WireObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.templateId !== undefined) {
            writer.uint32(10).string(message.templateId);
        }
        if (message._name !== undefined) {
            writer.uint32(18).string(message._name);
        }
        for (const v of message._tags) {
            writer.uint32(26).string(v);
        }
        if (message.x !== undefined) {
            writer.uint32(32).uint32(message.x);
        }
        if (message.y !== undefined) {
            writer.uint32(40).uint32(message.y);
        }
        if (message.offsetX !== undefined) {
            writer.uint32(53).float(message.offsetX);
        }
        if (message.offsetY !== undefined) {
            writer.uint32(61).float(message.offsetY);
        }
        if (message.color !== undefined) {
            writer.uint32(66).string(message.color);
        }
        if (message.orientation !== undefined) {
            writer.uint32(72).uint32(message.orientation);
        }
        if (message.normal !== undefined) {
            writer.uint32(82).string(message.normal);
        }
        if (message.highlighted !== undefined) {
            writer.uint32(90).string(message.highlighted);
        }
        if (message.type !== undefined) {
            writer.uint32(96).int32(message.type);
        }
        if (message.width !== undefined) {
            writer.uint32(104).uint32(message.width);
        }
        if (message.height !== undefined) {
            writer.uint32(112).uint32(message.height);
        }
        if (message.extensionClass !== undefined) {
            writer.uint32(122).string(message.extensionClass);
        }
        if (message.previewMessage !== undefined) {
            writer.uint32(130).string(message.previewMessage);
        }
        if (message.distThreshold !== undefined) {
            writer.uint32(136).uint32(message.distThreshold);
        }
        if (message.propertiesJson !== undefined) {
            writer.uint32(146).string(message.propertiesJson);
        }
        if (message.sound !== undefined) {
            exports.Sound.encode(message.sound, writer.uint32(154).fork()).ldelim();
        }
        if (message.objectStartTime !== undefined) {
            exports.ObjectTime.encode(message.objectStartTime, writer.uint32(162).fork()).ldelim();
        }
        if (message.objectExpireTime !== undefined) {
            exports.ObjectTime.encode(message.objectExpireTime, writer.uint32(170).fork()).ldelim();
        }
        if (message.id !== undefined) {
            writer.uint32(178).string(message.id);
        }
        if (message.customState !== undefined) {
            writer.uint32(186).string(message.customState);
        }
        if (message.objectPlacerId !== undefined) {
            writer.uint32(194).string(message.objectPlacerId);
        }
        if (message.numGoKarts !== undefined) {
            writer.uint32(200).uint32(message.numGoKarts);
        }
        if (message.spritesheet !== undefined) {
            exports.WireObjectSpritesheet.encode(message.spritesheet, writer.uint32(210).fork()).ldelim();
        }
        if (message.zIndex !== undefined) {
            writer.uint32(221).float(message.zIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWireObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.templateId = reader.string();
                    break;
                case 2:
                    message._name = reader.string();
                    break;
                case 3:
                    message._tags.push(reader.string());
                    break;
                case 4:
                    message.x = reader.uint32();
                    break;
                case 5:
                    message.y = reader.uint32();
                    break;
                case 6:
                    message.offsetX = reader.float();
                    break;
                case 7:
                    message.offsetY = reader.float();
                    break;
                case 8:
                    message.color = reader.string();
                    break;
                case 9:
                    message.orientation = reader.uint32();
                    break;
                case 10:
                    message.normal = reader.string();
                    break;
                case 11:
                    message.highlighted = reader.string();
                    break;
                case 12:
                    message.type = reader.int32();
                    break;
                case 13:
                    message.width = reader.uint32();
                    break;
                case 14:
                    message.height = reader.uint32();
                    break;
                case 15:
                    message.extensionClass = reader.string();
                    break;
                case 16:
                    message.previewMessage = reader.string();
                    break;
                case 17:
                    message.distThreshold = reader.uint32();
                    break;
                case 18:
                    message.propertiesJson = reader.string();
                    break;
                case 19:
                    message.sound = exports.Sound.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.objectStartTime = exports.ObjectTime.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.objectExpireTime = exports.ObjectTime.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.id = reader.string();
                    break;
                case 23:
                    message.customState = reader.string();
                    break;
                case 24:
                    message.objectPlacerId = reader.string();
                    break;
                case 25:
                    message.numGoKarts = reader.uint32();
                    break;
                case 26:
                    message.spritesheet = exports.WireObjectSpritesheet.decode(reader, reader.uint32());
                    break;
                case 27:
                    message.zIndex = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceMemberInfo() {
    return { roles: {}, role: "" };
}
exports.SpaceMemberInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.roles).forEach(([key, value]) => {
            exports.SpaceMemberInfo_RolesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        if (message.name !== undefined) {
            writer.uint32(18).string(message.name);
        }
        if (message.currentlyEquippedWearables !== undefined) {
            exports.DBOutfit.encode(message.currentlyEquippedWearables, writer.uint32(34).fork()).ldelim();
        }
        if (message.deskInfo !== undefined) {
            exports.DeskInfo.encode(message.deskInfo, writer.uint32(42).fork()).ldelim();
        }
        if (message.allowScreenPointer !== undefined) {
            writer.uint32(48).bool(message.allowScreenPointer);
        }
        if (message.role !== "") {
            writer.uint32(58).string(message.role);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceMemberInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SpaceMemberInfo_RolesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.roles[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 4:
                    message.currentlyEquippedWearables = exports.DBOutfit.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.deskInfo = exports.DeskInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.allowScreenPointer = reader.bool();
                    break;
                case 7:
                    message.role = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceMemberInfo_RolesEntry() {
    return { key: "", value: false };
}
exports.SpaceMemberInfo_RolesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value === true) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceMemberInfo_RolesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseBackedUpDeskObject() {
    return { obj: undefined, offsetX: 0, offsetY: 0 };
}
exports.BackedUpDeskObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.obj !== undefined) {
            exports.WireObject.encode(message.obj, writer.uint32(10).fork()).ldelim();
        }
        if (message.offsetX !== 0) {
            writer.uint32(16).uint32(message.offsetX);
        }
        if (message.offsetY !== 0) {
            writer.uint32(24).uint32(message.offsetY);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackedUpDeskObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.obj = exports.WireObject.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.offsetX = reader.uint32();
                    break;
                case 3:
                    message.offsetY = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDeskObjects() {
    return { objects: {} };
}
exports.DeskObjects = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.objects).forEach(([key, value]) => {
            exports.DeskObjects_ObjectsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeskObjects();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.DeskObjects_ObjectsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.objects[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDeskObjects_ObjectsEntry() {
    return { key: "", value: undefined };
}
exports.DeskObjects_ObjectsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.BackedUpDeskObject.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeskObjects_ObjectsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.BackedUpDeskObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDeskInfo() {
    return { deskId: "" };
}
exports.DeskInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deskId !== "") {
            writer.uint32(10).string(message.deskId);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        if (message.locked !== undefined) {
            writer.uint32(24).bool(message.locked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeskInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.deskId = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.locked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDeskInfoV2() {
    return {};
}
exports.DeskInfoV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deskId !== undefined) {
            writer.uint32(10).string(message.deskId);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        if (message.locked !== undefined) {
            writer.uint32(24).bool(message.locked);
        }
        if (message.lastDeskObjects !== undefined) {
            exports.DeskObjects.encode(message.lastDeskObjects, writer.uint32(34).fork()).ldelim();
        }
        if (message.mapId !== undefined) {
            writer.uint32(42).string(message.mapId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeskInfoV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.deskId = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.locked = reader.bool();
                    break;
                case 4:
                    message.lastDeskObjects = exports.DeskObjects.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.mapId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapAndDesk() {
    return { mapId: "", deskId: "" };
}
exports.MapAndDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.deskId !== "") {
            writer.uint32(18).string(message.deskId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapAndDesk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.deskId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSound() {
    return { src: "", volume: 0, loop: false, maxDistance: 0 };
}
exports.Sound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.volume !== 0) {
            writer.uint32(21).float(message.volume);
        }
        if (message.loop === true) {
            writer.uint32(24).bool(message.loop);
        }
        if (message.maxDistance !== 0) {
            writer.uint32(32).uint32(message.maxDistance);
        }
        if (message.isPositional !== undefined) {
            writer.uint32(40).bool(message.isPositional);
        }
        if (message.stream !== undefined) {
            writer.uint32(48).bool(message.stream);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSound();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 2:
                    message.volume = reader.float();
                    break;
                case 3:
                    message.loop = reader.bool();
                    break;
                case 4:
                    message.maxDistance = reader.uint32();
                    break;
                case 5:
                    message.isPositional = reader.bool();
                    break;
                case 6:
                    message.stream = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseObjectTime() {
    return { _seconds: 0 };
}
exports.ObjectTime = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message._seconds !== 0) {
            writer.uint32(8).uint32(message._seconds);
        }
        if (message._timezone !== undefined) {
            writer.uint32(18).string(message._timezone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseObjectTime();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message._seconds = reader.uint32();
                    break;
                case 2:
                    message._timezone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpace() {
    return { spaceId: "", x: 0, y: 0 };
}
exports.Space = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spaceId !== "") {
            writer.uint32(10).string(message.spaceId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.colored !== undefined) {
            writer.uint32(32).bool(message.colored);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpace();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spaceId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.colored = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseNookCoords() {
    return { coords: [] };
}
exports.NookCoords = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.coords) {
            exports.WirePoint.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNookCoords();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.coords.push(exports.WirePoint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAllowedUsers() {
    return { users: [] };
}
exports.AllowedUsers = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.users) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAllowedUsers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.users.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRequestUser() {
    return {};
}
exports.RequestUser = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== undefined) {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestUser();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRequestedUsers() {
    return { users: {} };
}
exports.RequestedUsers = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.users).forEach(([key, value]) => {
            exports.RequestedUsers_UsersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestedUsers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.RequestedUsers_UsersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.users[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRequestedUsers_UsersEntry() {
    return { key: "", value: undefined };
}
exports.RequestedUsers_UsersEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.RequestUser.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestedUsers_UsersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.RequestUser.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRecordingInfo() {
    return { active: false };
}
exports.RecordingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.active === true) {
            writer.uint32(24).bool(message.active);
        }
        if (message.initiatingPlayer !== undefined) {
            writer.uint32(10).string(message.initiatingPlayer);
        }
        if (message.egressId !== undefined) {
            writer.uint32(34).string(message.egressId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecordingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.active = reader.bool();
                    break;
                case 1:
                    message.initiatingPlayer = reader.string();
                    break;
                case 4:
                    message.egressId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseNookDiff() {
    return {};
}
exports.NookDiff = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nookCoords !== undefined) {
            exports.NookCoords.encode(message.nookCoords, writer.uint32(10).fork()).ldelim();
        }
        if (message.colored !== undefined) {
            writer.uint32(16).bool(message.colored);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        if (message.bookable !== undefined) {
            writer.uint32(32).bool(message.bookable);
        }
        if (message.capacity !== undefined) {
            writer.uint32(40).uint32(message.capacity);
        }
        if (message.restricted !== undefined) {
            writer.uint32(48).bool(message.restricted);
        }
        if (message.allowedUsers !== undefined) {
            exports.AllowedUsers.encode(message.allowedUsers, writer.uint32(58).fork()).ldelim();
        }
        if (message.requestedUsers !== undefined) {
            exports.RequestedUsers.encode(message.requestedUsers, writer.uint32(66).fork()).ldelim();
        }
        if (message.isInMeeting !== undefined) {
            writer.uint32(72).bool(message.isInMeeting);
        }
        if (message.isDesk !== undefined) {
            writer.uint32(80).bool(message.isDesk);
        }
        if (message.recordingInfo !== undefined) {
            exports.RecordingInfo.encode(message.recordingInfo, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNookDiff();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nookCoords = exports.NookCoords.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.colored = reader.bool();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.bookable = reader.bool();
                    break;
                case 5:
                    message.capacity = reader.uint32();
                    break;
                case 6:
                    message.restricted = reader.bool();
                    break;
                case 7:
                    message.allowedUsers = exports.AllowedUsers.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.requestedUsers = exports.RequestedUsers.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.isInMeeting = reader.bool();
                    break;
                case 10:
                    message.isDesk = reader.bool();
                    break;
                case 11:
                    message.recordingInfo = exports.RecordingInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWirePoint() {
    return { x: 0, y: 0 };
}
exports.WirePoint = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWirePoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpawnPoint() {
    return { x: 0, y: 0 };
}
exports.SpawnPoint = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        if (message.spawnId !== undefined) {
            writer.uint32(26).string(message.spawnId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpawnPoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                case 3:
                    message.spawnId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePortal() {
    return { x: 0, y: 0 };
}
exports.Portal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        if (message.targetMap !== undefined) {
            writer.uint32(26).string(message.targetMap);
        }
        if (message.targetUrl !== undefined) {
            writer.uint32(34).string(message.targetUrl);
        }
        if (message.targetX !== undefined) {
            writer.uint32(40).uint32(message.targetX);
        }
        if (message.targetY !== undefined) {
            writer.uint32(48).uint32(message.targetY);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePortal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                case 3:
                    message.targetMap = reader.string();
                    break;
                case 4:
                    message.targetUrl = reader.string();
                    break;
                case 5:
                    message.targetX = reader.uint32();
                    break;
                case 6:
                    message.targetY = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAnnouncer() {
    return { x: 0, y: 0 };
}
exports.Announcer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAnnouncer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAsset() {
    return { x: 0, y: 0, src: "" };
}
exports.Asset = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(13).float(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(21).float(message.y);
        }
        if (message.src !== "") {
            writer.uint32(26).string(message.src);
        }
        if (message.width !== undefined) {
            writer.uint32(32).uint32(message.width);
        }
        if (message.height !== undefined) {
            writer.uint32(40).uint32(message.height);
        }
        if (message.inFront !== undefined) {
            writer.uint32(48).bool(message.inFront);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAsset();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.src = reader.string();
                    break;
                case 4:
                    message.width = reader.uint32();
                    break;
                case 5:
                    message.height = reader.uint32();
                    break;
                case 6:
                    message.inFront = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAreaPosition() {
    return { x1: 0, y1: 0, x2: 0, y2: 0 };
}
exports.AreaPosition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x1 !== 0) {
            writer.uint32(8).uint32(message.x1);
        }
        if (message.y1 !== 0) {
            writer.uint32(16).uint32(message.y1);
        }
        if (message.x2 !== 0) {
            writer.uint32(24).uint32(message.x2);
        }
        if (message.y2 !== 0) {
            writer.uint32(32).uint32(message.y2);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAreaPosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x1 = reader.uint32();
                    break;
                case 2:
                    message.y1 = reader.uint32();
                    break;
                case 3:
                    message.x2 = reader.uint32();
                    break;
                case 4:
                    message.y2 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWireArea() {
    return { coords: [] };
}
exports.WireArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.category !== undefined) {
            writer.uint32(10).string(message.category);
        }
        for (const v of message.coords) {
            exports.AreaPosition.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWireArea();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.category = reader.string();
                    break;
                case 2:
                    message.coords.push(exports.AreaPosition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDBDesk() {
    return { coords: [] };
}
exports.DBDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.coords) {
            exports.AreaPosition.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDBDesk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.coords.push(exports.AreaPosition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetDimensions() {
    return { mapId: "", width: 0, height: 0 };
}
exports.MapSetDimensions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.width !== 0) {
            writer.uint32(16).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(24).uint32(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetDimensions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.width = reader.uint32();
                    break;
                case 3:
                    message.height = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetCollisions() {
    return { mapId: "", x: 0, y: 0, w: 0, h: 0, mask: "" };
}
exports.MapSetCollisions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.w !== 0) {
            writer.uint32(32).uint32(message.w);
        }
        if (message.h !== 0) {
            writer.uint32(40).uint32(message.h);
        }
        if (message.mask !== "") {
            writer.uint32(50).string(message.mask);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetCollisions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.w = reader.uint32();
                    break;
                case 5:
                    message.h = reader.uint32();
                    break;
                case 6:
                    message.mask = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetCollisionsBits() {
    return { mapId: "", overwrite: false, x: 0, y: 0, w: 0, h: 0, mask: new Uint8Array() };
}
exports.MapSetCollisionsBits = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.overwrite === true) {
            writer.uint32(16).bool(message.overwrite);
        }
        if (message.x !== 0) {
            writer.uint32(24).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(32).uint32(message.y);
        }
        if (message.w !== 0) {
            writer.uint32(40).uint32(message.w);
        }
        if (message.h !== 0) {
            writer.uint32(48).uint32(message.h);
        }
        if (message.mask.length !== 0) {
            writer.uint32(58).bytes(message.mask);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetCollisionsBits();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.overwrite = reader.bool();
                    break;
                case 3:
                    message.x = reader.uint32();
                    break;
                case 4:
                    message.y = reader.uint32();
                    break;
                case 5:
                    message.w = reader.uint32();
                    break;
                case 6:
                    message.h = reader.uint32();
                    break;
                case 7:
                    message.mask = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetBackgroundImagePath() {
    return { mapId: "", backgroundImagePath: "" };
}
exports.MapSetBackgroundImagePath = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.backgroundImagePath !== "") {
            writer.uint32(18).string(message.backgroundImagePath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetBackgroundImagePath();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.backgroundImagePath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetForegroundImagePath() {
    return { mapId: "", foregroundImagePath: "" };
}
exports.MapSetForegroundImagePath = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.foregroundImagePath !== "") {
            writer.uint32(18).string(message.foregroundImagePath);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetForegroundImagePath();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.foregroundImagePath = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetSprites() {
    return { mapId: "", sprites: [] };
}
exports.MapSetSprites = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        writer.uint32(18).fork();
        for (const v of message.sprites) {
            writer.uint32(v);
        }
        writer.ldelim();
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetSprites();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.sprites.push(reader.uint32());
                        }
                    }
                    else {
                        message.sprites.push(reader.uint32());
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetSpaces() {
    return { mapId: "", spaces: [] };
}
exports.MapSetSpaces = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.spaces) {
            exports.Space.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetSpaces();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.spaces.push(exports.Space.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetNooks() {
    return { mapId: "", nooks: {} };
}
exports.MapSetNooks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.nooks).forEach(([key, value]) => {
            exports.MapSetNooks_NooksEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.overwrite !== undefined) {
            writer.uint32(24).bool(message.overwrite);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetNooks();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetNooks_NooksEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.nooks[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.overwrite = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetNooks_NooksEntry() {
    return { key: "", value: undefined };
}
exports.MapSetNooks_NooksEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.NookDiff.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetNooks_NooksEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.NookDiff.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetSpawn() {
    return { mapId: "", spawn: undefined };
}
exports.MapSetSpawn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.spawn !== undefined) {
            exports.WirePoint.encode(message.spawn, writer.uint32(18).fork()).ldelim();
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetSpawn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.spawn = exports.WirePoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetSpawns() {
    return { mapId: "", spawns: [] };
}
exports.MapSetSpawns = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.spawns) {
            exports.SpawnPoint.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetSpawns();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.spawns.push(exports.SpawnPoint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetPortals() {
    return { mapId: "", portals: [] };
}
exports.MapSetPortals = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.portals) {
            exports.Portal.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetPortals();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.portals.push(exports.Portal.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetAnnouncer() {
    return { mapId: "", announcer: [] };
}
exports.MapSetAnnouncer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.announcer) {
            exports.Announcer.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetAnnouncer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.announcer.push(exports.Announcer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetAssets() {
    return { mapId: "", assets: [] };
}
exports.MapSetAssets = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.assets) {
            exports.Asset.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetAssets();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.assets.push(exports.Asset.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetObjects() {
    return { mapId: "", objects: {} };
}
exports.MapSetObjects = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.objects).forEach(([key, value]) => {
            exports.MapSetObjects_ObjectsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.updatesAreOverwrites !== undefined) {
            writer.uint32(24).bool(message.updatesAreOverwrites);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetObjects();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetObjects_ObjectsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.objects[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.updatesAreOverwrites = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetObjects_ObjectsEntry() {
    return { key: 0, value: undefined };
}
exports.MapSetObjects_ObjectsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.WireObject.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetObjects_ObjectsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.WireObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetName() {
    return { mapId: "", name: "" };
}
exports.MapSetName = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetName();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetMuteOnEntry() {
    return { mapId: "", muteOnEntry: false };
}
exports.MapSetMuteOnEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.muteOnEntry === true) {
            writer.uint32(16).bool(message.muteOnEntry);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetMuteOnEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.muteOnEntry = reader.bool();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetUseDrawnBG() {
    return { mapId: "", useDrawnBG: false };
}
exports.MapSetUseDrawnBG = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.useDrawnBG === true) {
            writer.uint32(16).bool(message.useDrawnBG);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetUseDrawnBG();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.useDrawnBG = reader.bool();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetWalls() {
    return { mapId: "", walls: {} };
}
exports.MapSetWalls = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.walls).forEach(([key, value]) => {
            exports.MapSetWalls_WallsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetWalls();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetWalls_WallsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.walls[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetWalls_WallsEntry() {
    return { key: "", value: "" };
}
exports.MapSetWalls_WallsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetWalls_WallsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetFloors() {
    return { mapId: "", floors: {} };
}
exports.MapSetFloors = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.floors).forEach(([key, value]) => {
            exports.MapSetFloors_FloorsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetFloors();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetFloors_FloorsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.floors[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetFloors_FloorsEntry() {
    return { key: "", value: "" };
}
exports.MapSetFloors_FloorsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetFloors_FloorsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetAreas() {
    return { mapId: "", areas: {} };
}
exports.MapSetAreas = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.areas).forEach(([key, value]) => {
            exports.MapSetAreas_AreasEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetAreas();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetAreas_AreasEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.areas[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetAreas_AreasEntry() {
    return { key: "", value: undefined };
}
exports.MapSetAreas_AreasEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.WireArea.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetAreas_AreasEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.WireArea.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapDeleteObject() {
    return { mapId: "", key: 0 };
}
exports.MapDeleteObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.key !== 0) {
            writer.uint32(16).uint32(message.key);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapDeleteObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.key = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapDeleteObjectById() {
    return { mapId: "", id: "" };
}
exports.MapDeleteObjectById = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapDeleteObjectById();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetMiniMapImagePath() {
    return { mapId: "", miniMapImagePath: "" };
}
exports.MapSetMiniMapImagePath = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.miniMapImagePath !== "") {
            writer.uint32(18).string(message.miniMapImagePath);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetMiniMapImagePath();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.miniMapImagePath = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetEnabledChats() {
    return { mapId: "", enabledChats: [] };
}
exports.MapSetEnabledChats = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.enabledChats) {
            writer.uint32(18).string(v);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetEnabledChats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.enabledChats.push(reader.string());
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetDescription() {
    return { mapId: "", description: "" };
}
exports.MapSetDescription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetDescription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetDecoration() {
    return { mapId: "", decoration: "" };
}
exports.MapSetDecoration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.decoration !== "") {
            writer.uint32(18).string(message.decoration);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetDecoration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.decoration = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetTutorialTasks() {
    return { mapId: "", tutorialTasks: undefined };
}
exports.MapSetTutorialTasks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.tutorialTasks !== undefined) {
            exports.WireTutorialTasks.encode(message.tutorialTasks, writer.uint32(18).fork()).ldelim();
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetTutorialTasks();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.tutorialTasks = exports.WireTutorialTasks.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWireTutorialTasks() {
    return { groupSetId: "", areas: [] };
}
exports.WireTutorialTasks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.groupSetId !== "") {
            writer.uint32(10).string(message.groupSetId);
        }
        for (const v of message.areas) {
            exports.TutorialTaskMapArea.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.autoStart !== undefined) {
            writer.uint32(24).bool(message.autoStart);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWireTutorialTasks();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.groupSetId = reader.string();
                    break;
                case 2:
                    message.areas.push(exports.TutorialTaskMapArea.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.autoStart = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTutorialTaskMapArea() {
    return { areaId: "", x: 0, y: 0, height: 0, width: 0 };
}
exports.TutorialTaskMapArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.areaId !== "") {
            writer.uint32(10).string(message.areaId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.height !== 0) {
            writer.uint32(32).uint32(message.height);
        }
        if (message.width !== 0) {
            writer.uint32(40).uint32(message.width);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTutorialTaskMapArea();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.areaId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.height = reader.uint32();
                    break;
                case 5:
                    message.width = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapSetScript() {
    return { mapId: "", script: "" };
}
exports.MapSetScript = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.script !== "") {
            writer.uint32(18).string(message.script);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapSetScript();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.script = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInventory() {
    return { items: {}, order: {} };
}
exports.Inventory = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.items).forEach(([key, value]) => {
            exports.Inventory_ItemsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        Object.entries(message.order).forEach(([key, value]) => {
            exports.Inventory_OrderEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInventory();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.Inventory_ItemsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.items[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    const entry2 = exports.Inventory_OrderEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.order[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInventory_ItemsEntry() {
    return { key: "", value: undefined };
}
exports.Inventory_ItemsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.InventoryItem.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInventory_ItemsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.InventoryItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInventory_OrderEntry() {
    return { key: "", value: "" };
}
exports.Inventory_OrderEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInventory_OrderEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInventoryItem() {
    return { count: 0 };
}
exports.InventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.count !== 0) {
            writer.uint32(8).uint32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInventoryItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceItem() {
    return { name: "", previewUrl: "", meta: {}, abilities: {} };
}
exports.SpaceItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.category !== undefined) {
            writer.uint32(18).string(message.category);
        }
        if (message.description !== undefined) {
            writer.uint32(26).string(message.description);
        }
        if (message.previewUrl !== "") {
            writer.uint32(34).string(message.previewUrl);
        }
        Object.entries(message.meta).forEach(([key, value]) => {
            exports.SpaceItem_MetaEntry.encode({ key: key, value }, writer.uint32(42).fork()).ldelim();
        });
        Object.entries(message.abilities).forEach(([key, value]) => {
            exports.SpaceItem_AbilitiesEntry.encode({ key: key, value }, writer.uint32(50).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.category = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.previewUrl = reader.string();
                    break;
                case 5:
                    const entry5 = exports.SpaceItem_MetaEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.meta[entry5.key] = entry5.value;
                    }
                    break;
                case 6:
                    const entry6 = exports.SpaceItem_AbilitiesEntry.decode(reader, reader.uint32());
                    if (entry6.value !== undefined) {
                        message.abilities[entry6.key] = entry6.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceItem_MetaEntry() {
    return { key: "", value: "" };
}
exports.SpaceItem_MetaEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceItem_MetaEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceItem_AbilitiesEntry() {
    return { key: "", value: undefined };
}
exports.SpaceItem_AbilitiesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.ItemAbility.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceItem_AbilitiesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.ItemAbility.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseItemAbility() {
    return { name: "" };
}
exports.ItemAbility = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseItemAbility();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapLocation() {
    return { map: "", x: 0, y: 0 };
}
exports.MapLocation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.map !== "") {
            writer.uint32(10).string(message.map);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapLocation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.map = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnterWithTeammatesLobbyUser() {
    return { id: "", name: "", outfitString: "" };
}
exports.EnterWithTeammatesLobbyUser = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.outfitString !== "") {
            writer.uint32(26).string(message.outfitString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnterWithTeammatesLobbyUser();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.outfitString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnterWithTeammatesLobbyStateUpdated() {
    return { users: [] };
}
exports.EnterWithTeammatesLobbyStateUpdated = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hostId !== undefined) {
            writer.uint32(10).string(message.hostId);
        }
        for (const v of message.users) {
            exports.EnterWithTeammatesLobbyUser.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnterWithTeammatesLobbyStateUpdated();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hostId = reader.string();
                    break;
                case 2:
                    message.users.push(exports.EnterWithTeammatesLobbyUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnterWithTeammatesHostInitiatesEnterSpace() {
    return { hostId: "" };
}
exports.EnterWithTeammatesHostInitiatesEnterSpace = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hostId !== "") {
            writer.uint32(10).string(message.hostId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnterWithTeammatesHostInitiatesEnterSpace();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hostId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseServerClientBatch() {
    return { events: [] };
}
exports.ServerClientBatch = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.events) {
            exports.ServerClientEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerClientBatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.events.push(exports.ServerClientEvent.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseServerClientEvent() {
    return { event: undefined };
}
exports.ServerClientEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a;
        switch ((_a = message.event) === null || _a === void 0 ? void 0 : _a.$case) {
            case "info":
                exports.Info.encode(message.event.info, writer.uint32(802).fork()).ldelim();
                break;
            case "warn":
                exports.Warn.encode(message.event.warn, writer.uint32(810).fork()).ldelim();
                break;
            case "error":
                exports.ErrorEvent.encode(message.event.error, writer.uint32(818).fork()).ldelim();
                break;
            case "ready":
                exports.Ready.encode(message.event.ready, writer.uint32(826).fork()).ldelim();
                break;
            case "serverHeartbeat":
                exports.ServerHeartbeat.encode(message.event.serverHeartbeat, writer.uint32(842).fork()).ldelim();
                break;
            case "transactionStatus":
                exports.TransactionStatus.encode(message.event.transactionStatus, writer.uint32(858).fork()).ldelim();
                break;
            case "playerMoves":
                exports.PlayerMoves.encode(message.event.playerMoves, writer.uint32(10).fork()).ldelim();
                break;
            case "playerSetsStatus":
                exports.PlayerSetsStatus.encode(message.event.playerSetsStatus, writer.uint32(42).fork()).ldelim();
                break;
            case "playerSpotlights":
                exports.PlayerSpotlights.encode(message.event.playerSpotlights, writer.uint32(50).fork()).ldelim();
                break;
            case "playerRings":
                exports.PlayerRings.encode(message.event.playerRings, writer.uint32(58).fork()).ldelim();
                break;
            case "playerChats":
                exports.PlayerChats.encode(message.event.playerChats, writer.uint32(74).fork()).ldelim();
                break;
            case "playerInteracts":
                exports.PlayerInteracts.encode(message.event.playerInteracts, writer.uint32(82).fork()).ldelim();
                break;
            case "playerGhosts":
                exports.PlayerGhosts.encode(message.event.playerGhosts, writer.uint32(90).fork()).ldelim();
                break;
            case "playerEntersWhisper":
                exports.PlayerEntersWhisper.encode(message.event.playerEntersWhisper, writer.uint32(98).fork()).ldelim();
                break;
            case "playerLeavesWhisper":
                exports.PlayerLeavesWhisper.encode(message.event.playerLeavesWhisper, writer.uint32(106).fork()).ldelim();
                break;
            case "playerActivelySpeaks":
                exports.PlayerActivelySpeaks.encode(message.event.playerActivelySpeaks, writer.uint32(114).fork()).ldelim();
                break;
            case "playerSetsWorkCondition":
                exports.PlayerSetsWorkCondition.encode(message.event.playerSetsWorkCondition, writer.uint32(130).fork()).ldelim();
                break;
            case "playerSetsName":
                exports.PlayerSetsName.encode(message.event.playerSetsName, writer.uint32(138).fork()).ldelim();
                break;
            case "playerSetsTextStatus":
                exports.PlayerSetsTextStatus.encode(message.event.playerSetsTextStatus, writer.uint32(146).fork()).ldelim();
                break;
            case "playerSetsEmojiStatus":
                exports.PlayerSetsEmojiStatus.encode(message.event.playerSetsEmojiStatus, writer.uint32(154).fork()).ldelim();
                break;
            case "playerSetsAffiliation":
                exports.PlayerSetsAffiliation.encode(message.event.playerSetsAffiliation, writer.uint32(162).fork()).ldelim();
                break;
            case "playerExits":
                exports.PlayerExits.encode(message.event.playerExits, writer.uint32(170).fork()).ldelim();
                break;
            case "respawnComplete":
                exports.RespawnComplete.encode(message.event.respawnComplete, writer.uint32(314).fork()).ldelim();
                break;
            case "playerSetsOutfitString":
                exports.PlayerSetsOutfitString.encode(message.event.playerSetsOutfitString, writer.uint32(322).fork()).ldelim();
                break;
            case "playerSetsIsSignedIn":
                exports.PlayerSetsIsSignedIn.encode(message.event.playerSetsIsSignedIn, writer.uint32(330).fork()).ldelim();
                break;
            case "spaceOverwrites":
                exports.SpaceOverwrites.encode(message.event.spaceOverwrites, writer.uint32(354).fork()).ldelim();
                break;
            case "spaceIsClosed":
                exports.SpaceIsClosed.encode(message.event.spaceIsClosed, writer.uint32(362).fork()).ldelim();
                break;
            case "playerEntersPortal":
                exports.PlayerEntersPortal.encode(message.event.playerEntersPortal, writer.uint32(370).fork()).ldelim();
                break;
            case "spaceSetsIdMapping":
                exports.SpaceSetsIdMapping.encode(message.event.spaceSetsIdMapping, writer.uint32(378).fork()).ldelim();
                break;
            case "playerSetsLastActive":
                exports.PlayerSetsLastActive.encode(message.event.playerSetsLastActive, writer.uint32(386).fork()).ldelim();
                break;
            case "playerShootsConfetti":
                exports.PlayerShootsConfetti.encode(message.event.playerShootsConfetti, writer.uint32(394).fork()).ldelim();
                break;
            case "playerSetsEventStatus":
                exports.PlayerSetsEventStatus.encode(message.event.playerSetsEventStatus, writer.uint32(402).fork()).ldelim();
                break;
            case "playerSetsInConversation":
                exports.PlayerSetsInConversation.encode(message.event.playerSetsInConversation, writer.uint32(410).fork()).ldelim();
                break;
            case "playerSetsCurrentDesk":
                exports.PlayerSetsCurrentDesk.encode(message.event.playerSetsCurrentDesk, writer.uint32(418).fork()).ldelim();
                break;
            case "playerSetsCurrentArea":
                exports.PlayerSetsCurrentArea.encode(message.event.playerSetsCurrentArea, writer.uint32(426).fork()).ldelim();
                break;
            case "playerSetsImagePointer":
                exports.PlayerSetsImagePointer.encode(message.event.playerSetsImagePointer, writer.uint32(434).fork()).ldelim();
                break;
            case "cookieFound":
                exports.CookieFound.encode(message.event.cookieFound, writer.uint32(442).fork()).ldelim();
                break;
            case "playerEntersWhisperV2":
                exports.PlayerEntersWhisperV2.encode(message.event.playerEntersWhisperV2, writer.uint32(450).fork()).ldelim();
                break;
            case "playerSetsGoKartId":
                exports.PlayerSetsGoKartId.encode(message.event.playerSetsGoKartId, writer.uint32(458).fork()).ldelim();
                break;
            case "mapSetDimensions":
                exports.MapSetDimensions.encode(message.event.mapSetDimensions, writer.uint32(466).fork()).ldelim();
                break;
            case "mapSetCollisions":
                exports.MapSetCollisions.encode(message.event.mapSetCollisions, writer.uint32(474).fork()).ldelim();
                break;
            case "mapSetBackgroundImagePath":
                exports.MapSetBackgroundImagePath.encode(message.event.mapSetBackgroundImagePath, writer.uint32(482).fork()).ldelim();
                break;
            case "mapSetForegroundImagePath":
                exports.MapSetForegroundImagePath.encode(message.event.mapSetForegroundImagePath, writer.uint32(490).fork()).ldelim();
                break;
            case "mapSetSprites":
                exports.MapSetSprites.encode(message.event.mapSetSprites, writer.uint32(498).fork()).ldelim();
                break;
            case "mapSetSpaces":
                exports.MapSetSpaces.encode(message.event.mapSetSpaces, writer.uint32(506).fork()).ldelim();
                break;
            case "mapSetSpawns":
                exports.MapSetSpawns.encode(message.event.mapSetSpawns, writer.uint32(514).fork()).ldelim();
                break;
            case "mapSetPortals":
                exports.MapSetPortals.encode(message.event.mapSetPortals, writer.uint32(522).fork()).ldelim();
                break;
            case "mapSetAnnouncer":
                exports.MapSetAnnouncer.encode(message.event.mapSetAnnouncer, writer.uint32(530).fork()).ldelim();
                break;
            case "mapSetAssets":
                exports.MapSetAssets.encode(message.event.mapSetAssets, writer.uint32(554).fork()).ldelim();
                break;
            case "mapSetObjects":
                exports.MapSetObjects.encode(message.event.mapSetObjects, writer.uint32(562).fork()).ldelim();
                break;
            case "mapSetName":
                exports.MapSetName.encode(message.event.mapSetName, writer.uint32(570).fork()).ldelim();
                break;
            case "mapSetMuteOnEntry":
                exports.MapSetMuteOnEntry.encode(message.event.mapSetMuteOnEntry, writer.uint32(586).fork()).ldelim();
                break;
            case "mapSetUseDrawnBG":
                exports.MapSetUseDrawnBG.encode(message.event.mapSetUseDrawnBG, writer.uint32(594).fork()).ldelim();
                break;
            case "mapSetWalls":
                exports.MapSetWalls.encode(message.event.mapSetWalls, writer.uint32(602).fork()).ldelim();
                break;
            case "mapSetFloors":
                exports.MapSetFloors.encode(message.event.mapSetFloors, writer.uint32(610).fork()).ldelim();
                break;
            case "mapSetAreas":
                exports.MapSetAreas.encode(message.event.mapSetAreas, writer.uint32(618).fork()).ldelim();
                break;
            case "mapDeleteObject":
                exports.MapDeleteObject.encode(message.event.mapDeleteObject, writer.uint32(626).fork()).ldelim();
                break;
            case "mapSetSpawn":
                exports.MapSetSpawn.encode(message.event.mapSetSpawn, writer.uint32(634).fork()).ldelim();
                break;
            case "playerSetsIsAlone":
                exports.PlayerSetsIsAlone.encode(message.event.playerSetsIsAlone, writer.uint32(642).fork()).ldelim();
                break;
            case "playerJoins":
                exports.PlayerJoins.encode(message.event.playerJoins, writer.uint32(650).fork()).ldelim();
                break;
            case "mapSetEnabledChats":
                exports.MapSetEnabledChats.encode(message.event.mapSetEnabledChats, writer.uint32(658).fork()).ldelim();
                break;
            case "mapSetDescription":
                exports.MapSetDescription.encode(message.event.mapSetDescription, writer.uint32(666).fork()).ldelim();
                break;
            case "mapSetDecoration":
                exports.MapSetDecoration.encode(message.event.mapSetDecoration, writer.uint32(674).fork()).ldelim();
                break;
            case "mapSetTutorialTasks":
                exports.MapSetTutorialTasks.encode(message.event.mapSetTutorialTasks, writer.uint32(682).fork()).ldelim();
                break;
            case "mapSetMiniMapImagePath":
                exports.MapSetMiniMapImagePath.encode(message.event.mapSetMiniMapImagePath, writer.uint32(690).fork()).ldelim();
                break;
            case "spacePlaysSound":
                exports.SpacePlaysSound.encode(message.event.spacePlaysSound, writer.uint32(698).fork()).ldelim();
                break;
            case "mapSetScript":
                exports.MapSetScript.encode(message.event.mapSetScript, writer.uint32(706).fork()).ldelim();
                break;
            case "playerSetsIsMobile":
                exports.PlayerSetsIsMobile.encode(message.event.playerSetsIsMobile, writer.uint32(722).fork()).ldelim();
                break;
            case "setScreenPointerServer":
                exports.SetScreenPointerServer.encode(message.event.setScreenPointerServer, writer.uint32(730).fork()).ldelim();
                break;
            case "playerSetsEmoteV2":
                exports.PlayerSetsEmoteV2.encode(message.event.playerSetsEmoteV2, writer.uint32(738).fork()).ldelim();
                break;
            case "playerSetsFocusModeEndTime":
                exports.PlayerSetsFocusModeEndTime.encode(message.event.playerSetsFocusModeEndTime, writer.uint32(746).fork()).ldelim();
                break;
            case "spaceSetsSpaceMembers":
                exports.SpaceSetsSpaceMembers.encode(message.event.spaceSetsSpaceMembers, writer.uint32(754).fork()).ldelim();
                break;
            case "customEvent":
                exports.CustomEvent.encode(message.event.customEvent, writer.uint32(762).fork()).ldelim();
                break;
            case "playerBlocks":
                exports.PlayerBlocks.encode(message.event.playerBlocks, writer.uint32(778).fork()).ldelim();
                break;
            case "playerUpdatesFocusModeStatus":
                exports.PlayerUpdatesFocusModeStatus.encode(message.event.playerUpdatesFocusModeStatus, writer.uint32(786).fork())
                    .ldelim();
                break;
            case "playerNotifies":
                exports.PlayerNotifies.encode(message.event.playerNotifies, writer.uint32(794).fork()).ldelim();
                break;
            case "playerSetsItemString":
                exports.PlayerSetsItemString.encode(message.event.playerSetsItemString, writer.uint32(866).fork()).ldelim();
                break;
            case "playerTriggersItem":
                exports.PlayerTriggersItem.encode(message.event.playerTriggersItem, writer.uint32(874).fork()).ldelim();
                break;
            case "playerSetsFollowTarget":
                exports.PlayerSetsFollowTarget.encode(message.event.playerSetsFollowTarget, writer.uint32(882).fork()).ldelim();
                break;
            case "playerRequestsToLead":
                exports.PlayerRequestsToLead.encode(message.event.playerRequestsToLead, writer.uint32(890).fork()).ldelim();
                break;
            case "playerSetsManualVideoSrc":
                exports.PlayerSetsManualVideoSrc.encode(message.event.playerSetsManualVideoSrc, writer.uint32(898).fork()).ldelim();
                break;
            case "playerSetsIsNpc":
                exports.PlayerSetsIsNpc.encode(message.event.playerSetsIsNpc, writer.uint32(906).fork()).ldelim();
                break;
            case "playerSetsSubtitle":
                exports.PlayerSetsSubtitle.encode(message.event.playerSetsSubtitle, writer.uint32(914).fork()).ldelim();
                break;
            case "mapCommitsChanges":
                exports.MapCommitsChanges.encode(message.event.mapCommitsChanges, writer.uint32(922).fork()).ldelim();
                break;
            case "playerUpdatesSession":
                exports.PlayerUpdatesSession.encode(message.event.playerUpdatesSession, writer.uint32(930).fork()).ldelim();
                break;
            case "mapMoveObject":
                exports.MapMoveObject.encode(message.event.mapMoveObject, writer.uint32(938).fork()).ldelim();
                break;
            case "playerEditsChatMessage":
                exports.PlayerEditsChatMessage.encode(message.event.playerEditsChatMessage, writer.uint32(946).fork()).ldelim();
                break;
            case "fxShakeObject":
                exports.FXShakeObject.encode(message.event.fxShakeObject, writer.uint32(954).fork()).ldelim();
                break;
            case "fxShakeCamera":
                exports.FXShakeCamera.encode(message.event.fxShakeCamera, writer.uint32(962).fork()).ldelim();
                break;
            case "playerSendsCommand":
                exports.PlayerSendsCommand.encode(message.event.playerSendsCommand, writer.uint32(970).fork()).ldelim();
                break;
            case "spaceRegistersCommand":
                exports.SpaceRegistersCommand.encode(message.event.spaceRegistersCommand, writer.uint32(978).fork()).ldelim();
                break;
            case "speakerUpdatesSession":
                exports.SpeakerUpdatesSession.encode(message.event.speakerUpdatesSession, writer.uint32(986).fork()).ldelim();
                break;
            case "playerUpdatesInventory":
                exports.PlayerUpdatesInventory.encode(message.event.playerUpdatesInventory, writer.uint32(994).fork()).ldelim();
                break;
            case "spaceUpdatesItems":
                exports.SpaceUpdatesItems.encode(message.event.spaceUpdatesItems, writer.uint32(1002).fork()).ldelim();
                break;
            case "playerSetsVehicleId":
                exports.PlayerSetsVehicleId.encode(message.event.playerSetsVehicleId, writer.uint32(1010).fork()).ldelim();
                break;
            case "playerSetsSpeedModifier":
                exports.PlayerSetsSpeedModifier.encode(message.event.playerSetsSpeedModifier, writer.uint32(1018).fork()).ldelim();
                break;
            case "playerHighFives":
                exports.PlayerHighFives.encode(message.event.playerHighFives, writer.uint32(1026).fork()).ldelim();
                break;
            case "spaceStopsSound":
                exports.SpaceStopsSound.encode(message.event.spaceStopsSound, writer.uint32(1042).fork()).ldelim();
                break;
            case "hipToBeSquare":
                exports.HipToBeSquare.encode(message.event.hipToBeSquare, writer.uint32(1050).fork()).ldelim();
                break;
            case "playerCrafts":
                exports.PlayerCrafts.encode(message.event.playerCrafts, writer.uint32(1058).fork()).ldelim();
                break;
            case "playerTriggersInventoryItem":
                exports.PlayerTriggersInventoryItem.encode(message.event.playerTriggersInventoryItem, writer.uint32(1066).fork())
                    .ldelim();
                break;
            case "playerSetsAllowScreenPointer":
                exports.PlayerSetsAllowScreenPointer.encode(message.event.playerSetsAllowScreenPointer, writer.uint32(1074).fork())
                    .ldelim();
                break;
            case "precomputedEnterLocation":
                exports.PrecomputedEnterLocation.encode(message.event.precomputedEnterLocation, writer.uint32(1082).fork()).ldelim();
                break;
            case "gotRequestMute":
                exports.GotRequestMute.encode(message.event.gotRequestMute, writer.uint32(1090).fork()).ldelim();
                break;
            case "playerSetsDeskInfo":
                exports.PlayerSetsDeskInfo.encode(message.event.playerSetsDeskInfo, writer.uint32(1098).fork()).ldelim();
                break;
            case "mapSetNooks":
                exports.MapSetNooks.encode(message.event.mapSetNooks, writer.uint32(1106).fork()).ldelim();
                break;
            case "dynamicGates":
                exports.DynamicGates.encode(message.event.dynamicGates, writer.uint32(1114).fork()).ldelim();
                break;
            case "playerWaves":
                exports.PlayerWaves.encode(message.event.playerWaves, writer.uint32(1122).fork()).ldelim();
                break;
            case "playerSetsPronouns":
                exports.PlayerSetsPronouns.encode(message.event.playerSetsPronouns, writer.uint32(1130).fork()).ldelim();
                break;
            case "playerSetsTitle":
                exports.PlayerSetsTitle.encode(message.event.playerSetsTitle, writer.uint32(1138).fork()).ldelim();
                break;
            case "playerSetsTimezone":
                exports.PlayerSetsTimezone.encode(message.event.playerSetsTimezone, writer.uint32(1146).fork()).ldelim();
                break;
            case "playerSetsDescription":
                exports.PlayerSetsDescription.encode(message.event.playerSetsDescription, writer.uint32(1154).fork()).ldelim();
                break;
            case "playerSetsPhone":
                exports.PlayerSetsPhone.encode(message.event.playerSetsPhone, writer.uint32(1162).fork()).ldelim();
                break;
            case "playerSetsPersonalImageUrl":
                exports.PlayerSetsPersonalImageUrl.encode(message.event.playerSetsPersonalImageUrl, writer.uint32(1170).fork())
                    .ldelim();
                break;
            case "playerSetsProfileImageUrl":
                exports.PlayerSetsProfileImageUrl.encode(message.event.playerSetsProfileImageUrl, writer.uint32(1178).fork()).ldelim();
                break;
            case "spaceSetsCapacity":
                exports.SpaceSetsCapacity.encode(message.event.spaceSetsCapacity, writer.uint32(1186).fork()).ldelim();
                break;
            case "spaceOverCapacityDeniesUser":
                exports.SpaceOverCapacityDeniesUser.encode(message.event.spaceOverCapacityDeniesUser, writer.uint32(1194).fork())
                    .ldelim();
                break;
            case "playerSetsAway":
                exports.PlayerSetsAway.encode(message.event.playerSetsAway, writer.uint32(1202).fork()).ldelim();
                break;
            case "mapSetCollisionsBits":
                exports.MapSetCollisionsBits.encode(message.event.mapSetCollisionsBits, writer.uint32(1210).fork()).ldelim();
                break;
            case "playerSetsCity":
                exports.PlayerSetsCity.encode(message.event.playerSetsCity, writer.uint32(1218).fork()).ldelim();
                break;
            case "playerSetsCountry":
                exports.PlayerSetsCountry.encode(message.event.playerSetsCountry, writer.uint32(1226).fork()).ldelim();
                break;
            case "playerSetsStartDate":
                exports.PlayerSetsStartDate.encode(message.event.playerSetsStartDate, writer.uint32(1234).fork()).ldelim();
                break;
            case "playerStartsRecording":
                exports.PlayerStartsRecording.encode(message.event.playerStartsRecording, writer.uint32(1250).fork()).ldelim();
                break;
            case "accessRequestsUpdated":
                exports.AccessRequestsUpdated.encode(message.event.accessRequestsUpdated, writer.uint32(1258).fork()).ldelim();
                break;
            case "accessRequestRespondedTo":
                exports.AccessRequestRespondedTo.encode(message.event.accessRequestRespondedTo, writer.uint32(1266).fork()).ldelim();
                break;
            case "spaceSetsGuestPassStatuses":
                exports.SpaceSetsGuestPassStatuses.encode(message.event.spaceSetsGuestPassStatuses, writer.uint32(1274).fork())
                    .ldelim();
                break;
            case "playerSetsAvailability":
                exports.PlayerSetsAvailability.encode(message.event.playerSetsAvailability, writer.uint32(1282).fork()).ldelim();
                break;
            case "subscriptionsUpdated":
                exports.SubscriptionsUpdated.encode(message.event.subscriptionsUpdated, writer.uint32(1290).fork()).ldelim();
                break;
            case "enterWithTeammatesLobbyStateUpdated":
                exports.EnterWithTeammatesLobbyStateUpdated.encode(message.event.enterWithTeammatesLobbyStateUpdated, writer.uint32(1298).fork()).ldelim();
                break;
            case "enterWithTeammatesHostInitiatesEnterSpace":
                exports.EnterWithTeammatesHostInitiatesEnterSpace.encode(message.event.enterWithTeammatesHostInitiatesEnterSpace, writer.uint32(1306).fork()).ldelim();
                break;
            case "spaceRolePermissionOverrideUpdated":
                exports.SpaceRolePermissionOverrideUpdated.encode(message.event.spaceRolePermissionOverrideUpdated, writer.uint32(1314).fork()).ldelim();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerClientEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 100:
                    message.event = { $case: "info", info: exports.Info.decode(reader, reader.uint32()) };
                    break;
                case 101:
                    message.event = { $case: "warn", warn: exports.Warn.decode(reader, reader.uint32()) };
                    break;
                case 102:
                    message.event = { $case: "error", error: exports.ErrorEvent.decode(reader, reader.uint32()) };
                    break;
                case 103:
                    message.event = { $case: "ready", ready: exports.Ready.decode(reader, reader.uint32()) };
                    break;
                case 105:
                    message.event = {
                        $case: "serverHeartbeat",
                        serverHeartbeat: exports.ServerHeartbeat.decode(reader, reader.uint32()),
                    };
                    break;
                case 107:
                    message.event = {
                        $case: "transactionStatus",
                        transactionStatus: exports.TransactionStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 1:
                    message.event = { $case: "playerMoves", playerMoves: exports.PlayerMoves.decode(reader, reader.uint32()) };
                    break;
                case 5:
                    message.event = {
                        $case: "playerSetsStatus",
                        playerSetsStatus: exports.PlayerSetsStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 6:
                    message.event = {
                        $case: "playerSpotlights",
                        playerSpotlights: exports.PlayerSpotlights.decode(reader, reader.uint32()),
                    };
                    break;
                case 7:
                    message.event = { $case: "playerRings", playerRings: exports.PlayerRings.decode(reader, reader.uint32()) };
                    break;
                case 9:
                    message.event = { $case: "playerChats", playerChats: exports.PlayerChats.decode(reader, reader.uint32()) };
                    break;
                case 10:
                    message.event = {
                        $case: "playerInteracts",
                        playerInteracts: exports.PlayerInteracts.decode(reader, reader.uint32()),
                    };
                    break;
                case 11:
                    message.event = { $case: "playerGhosts", playerGhosts: exports.PlayerGhosts.decode(reader, reader.uint32()) };
                    break;
                case 12:
                    message.event = {
                        $case: "playerEntersWhisper",
                        playerEntersWhisper: exports.PlayerEntersWhisper.decode(reader, reader.uint32()),
                    };
                    break;
                case 13:
                    message.event = {
                        $case: "playerLeavesWhisper",
                        playerLeavesWhisper: exports.PlayerLeavesWhisper.decode(reader, reader.uint32()),
                    };
                    break;
                case 14:
                    message.event = {
                        $case: "playerActivelySpeaks",
                        playerActivelySpeaks: exports.PlayerActivelySpeaks.decode(reader, reader.uint32()),
                    };
                    break;
                case 16:
                    message.event = {
                        $case: "playerSetsWorkCondition",
                        playerSetsWorkCondition: exports.PlayerSetsWorkCondition.decode(reader, reader.uint32()),
                    };
                    break;
                case 17:
                    message.event = { $case: "playerSetsName", playerSetsName: exports.PlayerSetsName.decode(reader, reader.uint32()) };
                    break;
                case 18:
                    message.event = {
                        $case: "playerSetsTextStatus",
                        playerSetsTextStatus: exports.PlayerSetsTextStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 19:
                    message.event = {
                        $case: "playerSetsEmojiStatus",
                        playerSetsEmojiStatus: exports.PlayerSetsEmojiStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 20:
                    message.event = {
                        $case: "playerSetsAffiliation",
                        playerSetsAffiliation: exports.PlayerSetsAffiliation.decode(reader, reader.uint32()),
                    };
                    break;
                case 21:
                    message.event = { $case: "playerExits", playerExits: exports.PlayerExits.decode(reader, reader.uint32()) };
                    break;
                case 39:
                    message.event = {
                        $case: "respawnComplete",
                        respawnComplete: exports.RespawnComplete.decode(reader, reader.uint32()),
                    };
                    break;
                case 40:
                    message.event = {
                        $case: "playerSetsOutfitString",
                        playerSetsOutfitString: exports.PlayerSetsOutfitString.decode(reader, reader.uint32()),
                    };
                    break;
                case 41:
                    message.event = {
                        $case: "playerSetsIsSignedIn",
                        playerSetsIsSignedIn: exports.PlayerSetsIsSignedIn.decode(reader, reader.uint32()),
                    };
                    break;
                case 44:
                    message.event = {
                        $case: "spaceOverwrites",
                        spaceOverwrites: exports.SpaceOverwrites.decode(reader, reader.uint32()),
                    };
                    break;
                case 45:
                    message.event = { $case: "spaceIsClosed", spaceIsClosed: exports.SpaceIsClosed.decode(reader, reader.uint32()) };
                    break;
                case 46:
                    message.event = {
                        $case: "playerEntersPortal",
                        playerEntersPortal: exports.PlayerEntersPortal.decode(reader, reader.uint32()),
                    };
                    break;
                case 47:
                    message.event = {
                        $case: "spaceSetsIdMapping",
                        spaceSetsIdMapping: exports.SpaceSetsIdMapping.decode(reader, reader.uint32()),
                    };
                    break;
                case 48:
                    message.event = {
                        $case: "playerSetsLastActive",
                        playerSetsLastActive: exports.PlayerSetsLastActive.decode(reader, reader.uint32()),
                    };
                    break;
                case 49:
                    message.event = {
                        $case: "playerShootsConfetti",
                        playerShootsConfetti: exports.PlayerShootsConfetti.decode(reader, reader.uint32()),
                    };
                    break;
                case 50:
                    message.event = {
                        $case: "playerSetsEventStatus",
                        playerSetsEventStatus: exports.PlayerSetsEventStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 51:
                    message.event = {
                        $case: "playerSetsInConversation",
                        playerSetsInConversation: exports.PlayerSetsInConversation.decode(reader, reader.uint32()),
                    };
                    break;
                case 52:
                    message.event = {
                        $case: "playerSetsCurrentDesk",
                        playerSetsCurrentDesk: exports.PlayerSetsCurrentDesk.decode(reader, reader.uint32()),
                    };
                    break;
                case 53:
                    message.event = {
                        $case: "playerSetsCurrentArea",
                        playerSetsCurrentArea: exports.PlayerSetsCurrentArea.decode(reader, reader.uint32()),
                    };
                    break;
                case 54:
                    message.event = {
                        $case: "playerSetsImagePointer",
                        playerSetsImagePointer: exports.PlayerSetsImagePointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 55:
                    message.event = { $case: "cookieFound", cookieFound: exports.CookieFound.decode(reader, reader.uint32()) };
                    break;
                case 56:
                    message.event = {
                        $case: "playerEntersWhisperV2",
                        playerEntersWhisperV2: exports.PlayerEntersWhisperV2.decode(reader, reader.uint32()),
                    };
                    break;
                case 57:
                    message.event = {
                        $case: "playerSetsGoKartId",
                        playerSetsGoKartId: exports.PlayerSetsGoKartId.decode(reader, reader.uint32()),
                    };
                    break;
                case 58:
                    message.event = {
                        $case: "mapSetDimensions",
                        mapSetDimensions: exports.MapSetDimensions.decode(reader, reader.uint32()),
                    };
                    break;
                case 59:
                    message.event = {
                        $case: "mapSetCollisions",
                        mapSetCollisions: exports.MapSetCollisions.decode(reader, reader.uint32()),
                    };
                    break;
                case 60:
                    message.event = {
                        $case: "mapSetBackgroundImagePath",
                        mapSetBackgroundImagePath: exports.MapSetBackgroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 61:
                    message.event = {
                        $case: "mapSetForegroundImagePath",
                        mapSetForegroundImagePath: exports.MapSetForegroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 62:
                    message.event = { $case: "mapSetSprites", mapSetSprites: exports.MapSetSprites.decode(reader, reader.uint32()) };
                    break;
                case 63:
                    message.event = { $case: "mapSetSpaces", mapSetSpaces: exports.MapSetSpaces.decode(reader, reader.uint32()) };
                    break;
                case 64:
                    message.event = { $case: "mapSetSpawns", mapSetSpawns: exports.MapSetSpawns.decode(reader, reader.uint32()) };
                    break;
                case 65:
                    message.event = { $case: "mapSetPortals", mapSetPortals: exports.MapSetPortals.decode(reader, reader.uint32()) };
                    break;
                case 66:
                    message.event = {
                        $case: "mapSetAnnouncer",
                        mapSetAnnouncer: exports.MapSetAnnouncer.decode(reader, reader.uint32()),
                    };
                    break;
                case 69:
                    message.event = { $case: "mapSetAssets", mapSetAssets: exports.MapSetAssets.decode(reader, reader.uint32()) };
                    break;
                case 70:
                    message.event = { $case: "mapSetObjects", mapSetObjects: exports.MapSetObjects.decode(reader, reader.uint32()) };
                    break;
                case 71:
                    message.event = { $case: "mapSetName", mapSetName: exports.MapSetName.decode(reader, reader.uint32()) };
                    break;
                case 73:
                    message.event = {
                        $case: "mapSetMuteOnEntry",
                        mapSetMuteOnEntry: exports.MapSetMuteOnEntry.decode(reader, reader.uint32()),
                    };
                    break;
                case 74:
                    message.event = {
                        $case: "mapSetUseDrawnBG",
                        mapSetUseDrawnBG: exports.MapSetUseDrawnBG.decode(reader, reader.uint32()),
                    };
                    break;
                case 75:
                    message.event = { $case: "mapSetWalls", mapSetWalls: exports.MapSetWalls.decode(reader, reader.uint32()) };
                    break;
                case 76:
                    message.event = { $case: "mapSetFloors", mapSetFloors: exports.MapSetFloors.decode(reader, reader.uint32()) };
                    break;
                case 77:
                    message.event = { $case: "mapSetAreas", mapSetAreas: exports.MapSetAreas.decode(reader, reader.uint32()) };
                    break;
                case 78:
                    message.event = {
                        $case: "mapDeleteObject",
                        mapDeleteObject: exports.MapDeleteObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 79:
                    message.event = { $case: "mapSetSpawn", mapSetSpawn: exports.MapSetSpawn.decode(reader, reader.uint32()) };
                    break;
                case 80:
                    message.event = {
                        $case: "playerSetsIsAlone",
                        playerSetsIsAlone: exports.PlayerSetsIsAlone.decode(reader, reader.uint32()),
                    };
                    break;
                case 81:
                    message.event = { $case: "playerJoins", playerJoins: exports.PlayerJoins.decode(reader, reader.uint32()) };
                    break;
                case 82:
                    message.event = {
                        $case: "mapSetEnabledChats",
                        mapSetEnabledChats: exports.MapSetEnabledChats.decode(reader, reader.uint32()),
                    };
                    break;
                case 83:
                    message.event = {
                        $case: "mapSetDescription",
                        mapSetDescription: exports.MapSetDescription.decode(reader, reader.uint32()),
                    };
                    break;
                case 84:
                    message.event = {
                        $case: "mapSetDecoration",
                        mapSetDecoration: exports.MapSetDecoration.decode(reader, reader.uint32()),
                    };
                    break;
                case 85:
                    message.event = {
                        $case: "mapSetTutorialTasks",
                        mapSetTutorialTasks: exports.MapSetTutorialTasks.decode(reader, reader.uint32()),
                    };
                    break;
                case 86:
                    message.event = {
                        $case: "mapSetMiniMapImagePath",
                        mapSetMiniMapImagePath: exports.MapSetMiniMapImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 87:
                    message.event = {
                        $case: "spacePlaysSound",
                        spacePlaysSound: exports.SpacePlaysSound.decode(reader, reader.uint32()),
                    };
                    break;
                case 88:
                    message.event = { $case: "mapSetScript", mapSetScript: exports.MapSetScript.decode(reader, reader.uint32()) };
                    break;
                case 90:
                    message.event = {
                        $case: "playerSetsIsMobile",
                        playerSetsIsMobile: exports.PlayerSetsIsMobile.decode(reader, reader.uint32()),
                    };
                    break;
                case 91:
                    message.event = {
                        $case: "setScreenPointerServer",
                        setScreenPointerServer: exports.SetScreenPointerServer.decode(reader, reader.uint32()),
                    };
                    break;
                case 92:
                    message.event = {
                        $case: "playerSetsEmoteV2",
                        playerSetsEmoteV2: exports.PlayerSetsEmoteV2.decode(reader, reader.uint32()),
                    };
                    break;
                case 93:
                    message.event = {
                        $case: "playerSetsFocusModeEndTime",
                        playerSetsFocusModeEndTime: exports.PlayerSetsFocusModeEndTime.decode(reader, reader.uint32()),
                    };
                    break;
                case 94:
                    message.event = {
                        $case: "spaceSetsSpaceMembers",
                        spaceSetsSpaceMembers: exports.SpaceSetsSpaceMembers.decode(reader, reader.uint32()),
                    };
                    break;
                case 95:
                    message.event = { $case: "customEvent", customEvent: exports.CustomEvent.decode(reader, reader.uint32()) };
                    break;
                case 97:
                    message.event = { $case: "playerBlocks", playerBlocks: exports.PlayerBlocks.decode(reader, reader.uint32()) };
                    break;
                case 98:
                    message.event = {
                        $case: "playerUpdatesFocusModeStatus",
                        playerUpdatesFocusModeStatus: exports.PlayerUpdatesFocusModeStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 99:
                    message.event = { $case: "playerNotifies", playerNotifies: exports.PlayerNotifies.decode(reader, reader.uint32()) };
                    break;
                case 108:
                    message.event = {
                        $case: "playerSetsItemString",
                        playerSetsItemString: exports.PlayerSetsItemString.decode(reader, reader.uint32()),
                    };
                    break;
                case 109:
                    message.event = {
                        $case: "playerTriggersItem",
                        playerTriggersItem: exports.PlayerTriggersItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 110:
                    message.event = {
                        $case: "playerSetsFollowTarget",
                        playerSetsFollowTarget: exports.PlayerSetsFollowTarget.decode(reader, reader.uint32()),
                    };
                    break;
                case 111:
                    message.event = {
                        $case: "playerRequestsToLead",
                        playerRequestsToLead: exports.PlayerRequestsToLead.decode(reader, reader.uint32()),
                    };
                    break;
                case 112:
                    message.event = {
                        $case: "playerSetsManualVideoSrc",
                        playerSetsManualVideoSrc: exports.PlayerSetsManualVideoSrc.decode(reader, reader.uint32()),
                    };
                    break;
                case 113:
                    message.event = {
                        $case: "playerSetsIsNpc",
                        playerSetsIsNpc: exports.PlayerSetsIsNpc.decode(reader, reader.uint32()),
                    };
                    break;
                case 114:
                    message.event = {
                        $case: "playerSetsSubtitle",
                        playerSetsSubtitle: exports.PlayerSetsSubtitle.decode(reader, reader.uint32()),
                    };
                    break;
                case 115:
                    message.event = {
                        $case: "mapCommitsChanges",
                        mapCommitsChanges: exports.MapCommitsChanges.decode(reader, reader.uint32()),
                    };
                    break;
                case 116:
                    message.event = {
                        $case: "playerUpdatesSession",
                        playerUpdatesSession: exports.PlayerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 117:
                    message.event = { $case: "mapMoveObject", mapMoveObject: exports.MapMoveObject.decode(reader, reader.uint32()) };
                    break;
                case 118:
                    message.event = {
                        $case: "playerEditsChatMessage",
                        playerEditsChatMessage: exports.PlayerEditsChatMessage.decode(reader, reader.uint32()),
                    };
                    break;
                case 119:
                    message.event = { $case: "fxShakeObject", fxShakeObject: exports.FXShakeObject.decode(reader, reader.uint32()) };
                    break;
                case 120:
                    message.event = { $case: "fxShakeCamera", fxShakeCamera: exports.FXShakeCamera.decode(reader, reader.uint32()) };
                    break;
                case 121:
                    message.event = {
                        $case: "playerSendsCommand",
                        playerSendsCommand: exports.PlayerSendsCommand.decode(reader, reader.uint32()),
                    };
                    break;
                case 122:
                    message.event = {
                        $case: "spaceRegistersCommand",
                        spaceRegistersCommand: exports.SpaceRegistersCommand.decode(reader, reader.uint32()),
                    };
                    break;
                case 123:
                    message.event = {
                        $case: "speakerUpdatesSession",
                        speakerUpdatesSession: exports.SpeakerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 124:
                    message.event = {
                        $case: "playerUpdatesInventory",
                        playerUpdatesInventory: exports.PlayerUpdatesInventory.decode(reader, reader.uint32()),
                    };
                    break;
                case 125:
                    message.event = {
                        $case: "spaceUpdatesItems",
                        spaceUpdatesItems: exports.SpaceUpdatesItems.decode(reader, reader.uint32()),
                    };
                    break;
                case 126:
                    message.event = {
                        $case: "playerSetsVehicleId",
                        playerSetsVehicleId: exports.PlayerSetsVehicleId.decode(reader, reader.uint32()),
                    };
                    break;
                case 127:
                    message.event = {
                        $case: "playerSetsSpeedModifier",
                        playerSetsSpeedModifier: exports.PlayerSetsSpeedModifier.decode(reader, reader.uint32()),
                    };
                    break;
                case 128:
                    message.event = {
                        $case: "playerHighFives",
                        playerHighFives: exports.PlayerHighFives.decode(reader, reader.uint32()),
                    };
                    break;
                case 130:
                    message.event = {
                        $case: "spaceStopsSound",
                        spaceStopsSound: exports.SpaceStopsSound.decode(reader, reader.uint32()),
                    };
                    break;
                case 131:
                    message.event = { $case: "hipToBeSquare", hipToBeSquare: exports.HipToBeSquare.decode(reader, reader.uint32()) };
                    break;
                case 132:
                    message.event = { $case: "playerCrafts", playerCrafts: exports.PlayerCrafts.decode(reader, reader.uint32()) };
                    break;
                case 133:
                    message.event = {
                        $case: "playerTriggersInventoryItem",
                        playerTriggersInventoryItem: exports.PlayerTriggersInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 134:
                    message.event = {
                        $case: "playerSetsAllowScreenPointer",
                        playerSetsAllowScreenPointer: exports.PlayerSetsAllowScreenPointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 135:
                    message.event = {
                        $case: "precomputedEnterLocation",
                        precomputedEnterLocation: exports.PrecomputedEnterLocation.decode(reader, reader.uint32()),
                    };
                    break;
                case 136:
                    message.event = { $case: "gotRequestMute", gotRequestMute: exports.GotRequestMute.decode(reader, reader.uint32()) };
                    break;
                case 137:
                    message.event = {
                        $case: "playerSetsDeskInfo",
                        playerSetsDeskInfo: exports.PlayerSetsDeskInfo.decode(reader, reader.uint32()),
                    };
                    break;
                case 138:
                    message.event = { $case: "mapSetNooks", mapSetNooks: exports.MapSetNooks.decode(reader, reader.uint32()) };
                    break;
                case 139:
                    message.event = { $case: "dynamicGates", dynamicGates: exports.DynamicGates.decode(reader, reader.uint32()) };
                    break;
                case 140:
                    message.event = { $case: "playerWaves", playerWaves: exports.PlayerWaves.decode(reader, reader.uint32()) };
                    break;
                case 141:
                    message.event = {
                        $case: "playerSetsPronouns",
                        playerSetsPronouns: exports.PlayerSetsPronouns.decode(reader, reader.uint32()),
                    };
                    break;
                case 142:
                    message.event = {
                        $case: "playerSetsTitle",
                        playerSetsTitle: exports.PlayerSetsTitle.decode(reader, reader.uint32()),
                    };
                    break;
                case 143:
                    message.event = {
                        $case: "playerSetsTimezone",
                        playerSetsTimezone: exports.PlayerSetsTimezone.decode(reader, reader.uint32()),
                    };
                    break;
                case 144:
                    message.event = {
                        $case: "playerSetsDescription",
                        playerSetsDescription: exports.PlayerSetsDescription.decode(reader, reader.uint32()),
                    };
                    break;
                case 145:
                    message.event = {
                        $case: "playerSetsPhone",
                        playerSetsPhone: exports.PlayerSetsPhone.decode(reader, reader.uint32()),
                    };
                    break;
                case 146:
                    message.event = {
                        $case: "playerSetsPersonalImageUrl",
                        playerSetsPersonalImageUrl: exports.PlayerSetsPersonalImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 147:
                    message.event = {
                        $case: "playerSetsProfileImageUrl",
                        playerSetsProfileImageUrl: exports.PlayerSetsProfileImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 148:
                    message.event = {
                        $case: "spaceSetsCapacity",
                        spaceSetsCapacity: exports.SpaceSetsCapacity.decode(reader, reader.uint32()),
                    };
                    break;
                case 149:
                    message.event = {
                        $case: "spaceOverCapacityDeniesUser",
                        spaceOverCapacityDeniesUser: exports.SpaceOverCapacityDeniesUser.decode(reader, reader.uint32()),
                    };
                    break;
                case 150:
                    message.event = { $case: "playerSetsAway", playerSetsAway: exports.PlayerSetsAway.decode(reader, reader.uint32()) };
                    break;
                case 151:
                    message.event = {
                        $case: "mapSetCollisionsBits",
                        mapSetCollisionsBits: exports.MapSetCollisionsBits.decode(reader, reader.uint32()),
                    };
                    break;
                case 152:
                    message.event = { $case: "playerSetsCity", playerSetsCity: exports.PlayerSetsCity.decode(reader, reader.uint32()) };
                    break;
                case 153:
                    message.event = {
                        $case: "playerSetsCountry",
                        playerSetsCountry: exports.PlayerSetsCountry.decode(reader, reader.uint32()),
                    };
                    break;
                case 154:
                    message.event = {
                        $case: "playerSetsStartDate",
                        playerSetsStartDate: exports.PlayerSetsStartDate.decode(reader, reader.uint32()),
                    };
                    break;
                case 156:
                    message.event = {
                        $case: "playerStartsRecording",
                        playerStartsRecording: exports.PlayerStartsRecording.decode(reader, reader.uint32()),
                    };
                    break;
                case 157:
                    message.event = {
                        $case: "accessRequestsUpdated",
                        accessRequestsUpdated: exports.AccessRequestsUpdated.decode(reader, reader.uint32()),
                    };
                    break;
                case 158:
                    message.event = {
                        $case: "accessRequestRespondedTo",
                        accessRequestRespondedTo: exports.AccessRequestRespondedTo.decode(reader, reader.uint32()),
                    };
                    break;
                case 159:
                    message.event = {
                        $case: "spaceSetsGuestPassStatuses",
                        spaceSetsGuestPassStatuses: exports.SpaceSetsGuestPassStatuses.decode(reader, reader.uint32()),
                    };
                    break;
                case 160:
                    message.event = {
                        $case: "playerSetsAvailability",
                        playerSetsAvailability: exports.PlayerSetsAvailability.decode(reader, reader.uint32()),
                    };
                    break;
                case 161:
                    message.event = {
                        $case: "subscriptionsUpdated",
                        subscriptionsUpdated: exports.SubscriptionsUpdated.decode(reader, reader.uint32()),
                    };
                    break;
                case 162:
                    message.event = {
                        $case: "enterWithTeammatesLobbyStateUpdated",
                        enterWithTeammatesLobbyStateUpdated: exports.EnterWithTeammatesLobbyStateUpdated.decode(reader, reader.uint32()),
                    };
                    break;
                case 163:
                    message.event = {
                        $case: "enterWithTeammatesHostInitiatesEnterSpace",
                        enterWithTeammatesHostInitiatesEnterSpace: exports.EnterWithTeammatesHostInitiatesEnterSpace.decode(reader, reader.uint32()),
                    };
                    break;
                case 164:
                    message.event = {
                        $case: "spaceRolePermissionOverrideUpdated",
                        spaceRolePermissionOverrideUpdated: exports.SpaceRolePermissionOverrideUpdated.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSubscriptionsUpdated() {
    return { subscriptions: [] };
}
exports.SubscriptionsUpdated = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.subscriptions) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscriptionsUpdated();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subscriptions.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseServerHeartbeat() {
    return { lastRTT: 0 };
}
exports.ServerHeartbeat = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.lastRTT !== 0) {
            writer.uint32(8).uint32(message.lastRTT);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerHeartbeat();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lastRTT = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInfo() {
    return { message: "" };
}
exports.Info = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWarn() {
    return { message: "" };
}
exports.Warn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWarn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseErrorEvent() {
    return { message: "", code: 0 };
}
exports.ErrorEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        if (message.code !== 0) {
            writer.uint32(16).uint32(message.code);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseErrorEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                case 2:
                    message.code = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseReady() {
    return { id: "" };
}
exports.Ready = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReady();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTransactionStatus() {
    return { txnId: 0, succeeded: false };
}
exports.TransactionStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txnId !== 0) {
            writer.uint32(8).uint32(message.txnId);
        }
        if (message.succeeded === true) {
            writer.uint32(16).bool(message.succeeded);
        }
        if (message.reason !== undefined) {
            writer.uint32(26).string(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txnId = reader.uint32();
                    break;
                case 2:
                    message.succeeded = reader.bool();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerJoins() {
    return { encId: 0 };
}
exports.PlayerJoins = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerJoins();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseGotRequestMute() {
    return { muterId: "", video: false };
}
exports.GotRequestMute = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.muterId !== "") {
            writer.uint32(10).string(message.muterId);
        }
        if (message.video === true) {
            writer.uint32(16).bool(message.video);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGotRequestMute();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.muterId = reader.string();
                    break;
                case 2:
                    message.video = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerMoves() {
    return { encId: 0, lastInputId: 0 };
}
exports.PlayerMoves = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.x !== undefined) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== undefined) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.direction !== undefined) {
            writer.uint32(32).int32(message.direction);
        }
        if (message.mapId !== undefined) {
            writer.uint32(42).string(message.mapId);
        }
        if (message.lastInputId !== 0) {
            writer.uint32(48).uint32(message.lastInputId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerMoves();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.direction = reader.int32();
                    break;
                case 5:
                    message.mapId = reader.string();
                    break;
                case 6:
                    message.lastInputId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsStatus() {
    return { encId: 0, busy: false };
}
exports.PlayerSetsStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.busy === true) {
            writer.uint32(16).bool(message.busy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.busy = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsAvailability() {
    return { encId: 0, status: "" };
}
exports.PlayerSetsAvailability = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.status !== "") {
            writer.uint32(18).string(message.status);
        }
        if (message.statusUpdatedAt !== undefined) {
            writer.uint32(26).string(message.statusUpdatedAt);
        }
        if (message.statusEndOption !== undefined) {
            writer.uint32(34).string(message.statusEndOption);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsAvailability();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.status = reader.string();
                    break;
                case 3:
                    message.statusUpdatedAt = reader.string();
                    break;
                case 4:
                    message.statusEndOption = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSpotlights() {
    return { encId: 0, spotlightedBy: 0, spotlighted: 0 };
}
exports.PlayerSpotlights = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(16).uint32(message.encId);
        }
        if (message.spotlightedBy !== 0) {
            writer.uint32(8).uint32(message.spotlightedBy);
        }
        if (message.spotlighted !== 0) {
            writer.uint32(24).uint32(message.spotlighted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSpotlights();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.encId = reader.uint32();
                    break;
                case 1:
                    message.spotlightedBy = reader.uint32();
                    break;
                case 3:
                    message.spotlighted = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerRings() {
    return { encId: 0 };
}
exports.PlayerRings = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerRings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsImagePointer() {
    return { encId: 0, objectId: "", x: 0, y: 0 };
}
exports.PlayerSetsImagePointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.objectId !== "") {
            writer.uint32(18).string(message.objectId);
        }
        if (message.x !== 0) {
            writer.uint32(25).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(33).double(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsImagePointer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.objectId = reader.string();
                    break;
                case 3:
                    message.x = reader.double();
                    break;
                case 4:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetScreenPointerServer() {
    return { encId: 0, screenId: "", x: 0, y: 0, color: "" };
}
exports.SetScreenPointerServer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.screenId !== "") {
            writer.uint32(18).string(message.screenId);
        }
        if (message.x !== 0) {
            writer.uint32(25).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(33).double(message.y);
        }
        if (message.color !== "") {
            writer.uint32(42).string(message.color);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetScreenPointerServer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.screenId = reader.string();
                    break;
                case 3:
                    message.x = reader.double();
                    break;
                case 4:
                    message.y = reader.double();
                    break;
                case 5:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerChats() {
    return { senderId: "", recipient: "", contents: "", senderName: "", messageType: "", unixTime: 0 };
}
exports.PlayerChats = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.senderId !== "") {
            writer.uint32(10).string(message.senderId);
        }
        if (message.recipient !== "") {
            writer.uint32(18).string(message.recipient);
        }
        if (message.contents !== "") {
            writer.uint32(26).string(message.contents);
        }
        if (message.senderName !== "") {
            writer.uint32(34).string(message.senderName);
        }
        if (message.timestamp !== undefined) {
            exports.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.messageType !== "") {
            writer.uint32(50).string(message.messageType);
        }
        if (message.unixTime !== 0) {
            writer.uint32(57).double(message.unixTime);
        }
        if (message.id !== undefined) {
            writer.uint32(66).string(message.id);
        }
        if (message.roomId !== undefined) {
            writer.uint32(74).string(message.roomId);
        }
        if (message.approved !== undefined) {
            writer.uint32(80).bool(message.approved);
        }
        if (message.nookId !== undefined) {
            writer.uint32(90).string(message.nookId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerChats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.senderId = reader.string();
                    break;
                case 2:
                    message.recipient = reader.string();
                    break;
                case 3:
                    message.contents = reader.string();
                    break;
                case 4:
                    message.senderName = reader.string();
                    break;
                case 5:
                    message.timestamp = exports.Timestamp.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.messageType = reader.string();
                    break;
                case 7:
                    message.unixTime = reader.double();
                    break;
                case 8:
                    message.id = reader.string();
                    break;
                case 9:
                    message.roomId = reader.string();
                    break;
                case 10:
                    message.approved = reader.bool();
                    break;
                case 11:
                    message.nookId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerWaves() {
    return { encId: 0, targetId: "", isReply: false };
}
exports.PlayerWaves = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.targetId !== "") {
            writer.uint32(18).string(message.targetId);
        }
        if (message.isReply === true) {
            writer.uint32(24).bool(message.isReply);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerWaves();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.isReply = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTimestamp() {
    return { seconds: 0, nanoseconds: 0 };
}
exports.Timestamp = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seconds !== 0) {
            writer.uint32(13).float(message.seconds);
        }
        if (message.nanoseconds !== 0) {
            writer.uint32(21).float(message.nanoseconds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.float();
                    break;
                case 2:
                    message.nanoseconds = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerInteracts() {
    return { encId: 0, objId: "" };
}
exports.PlayerInteracts = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.objId !== "") {
            writer.uint32(18).string(message.objId);
        }
        if (message.mapId !== undefined) {
            writer.uint32(34).string(message.mapId);
        }
        if (message.dataJson !== undefined) {
            writer.uint32(26).string(message.dataJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerInteracts();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.objId = reader.string();
                    break;
                case 4:
                    message.mapId = reader.string();
                    break;
                case 3:
                    message.dataJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerGhosts() {
    return { encId: 0, ghost: 0 };
}
exports.PlayerGhosts = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.ghost !== 0) {
            writer.uint32(16).uint32(message.ghost);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerGhosts();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.ghost = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerEntersWhisper() {
    return { encId: 0, whisperRecipient: "", whisperId: "" };
}
exports.PlayerEntersWhisper = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.whisperRecipient !== "") {
            writer.uint32(18).string(message.whisperRecipient);
        }
        if (message.whisperId !== "") {
            writer.uint32(26).string(message.whisperId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerEntersWhisper();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.whisperRecipient = reader.string();
                    break;
                case 3:
                    message.whisperId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerEntersWhisperV2() {
    return { encId: 0, encIdTarget: 0, whisperId: "" };
}
exports.PlayerEntersWhisperV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.encIdTarget !== 0) {
            writer.uint32(16).uint32(message.encIdTarget);
        }
        if (message.whisperId !== "") {
            writer.uint32(26).string(message.whisperId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerEntersWhisperV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.encIdTarget = reader.uint32();
                    break;
                case 3:
                    message.whisperId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerLeavesWhisper() {
    return { encId: 0 };
}
exports.PlayerLeavesWhisper = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerLeavesWhisper();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerActivelySpeaks() {
    return { encId: 0, activelySpeaking: 0 };
}
exports.PlayerActivelySpeaks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.activelySpeaking !== 0) {
            writer.uint32(16).uint32(message.activelySpeaking);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerActivelySpeaks();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.activelySpeaking = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsEmoteV2() {
    return { encId: 0 };
}
exports.PlayerSetsEmoteV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.emote !== undefined) {
            writer.uint32(18).string(message.emote);
        }
        if (message.count !== undefined) {
            writer.uint32(24).uint32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsEmoteV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.emote = reader.string();
                    break;
                case 3:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsWorkCondition() {
    return { encId: 0, workCondition: 0 };
}
exports.PlayerSetsWorkCondition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.workCondition !== 0) {
            writer.uint32(16).uint32(message.workCondition);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsWorkCondition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.workCondition = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsLastActive() {
    return { encId: 0, lastActive: "" };
}
exports.PlayerSetsLastActive = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.lastActive !== "") {
            writer.uint32(18).string(message.lastActive);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsLastActive();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.lastActive = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsName() {
    return { encId: 0, name: "" };
}
exports.PlayerSetsName = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsName();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsTextStatus() {
    return { encId: 0, textStatus: "" };
}
exports.PlayerSetsTextStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.textStatus !== "") {
            writer.uint32(18).string(message.textStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsTextStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.textStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsPronouns() {
    return { encId: 0, pronouns: "" };
}
exports.PlayerSetsPronouns = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.pronouns !== "") {
            writer.uint32(18).string(message.pronouns);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsPronouns();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.pronouns = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsTitle() {
    return { encId: 0, title: "" };
}
exports.PlayerSetsTitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.title !== "") {
            writer.uint32(18).string(message.title);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsTitle();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsCity() {
    return { encId: 0, city: "" };
}
exports.PlayerSetsCity = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.city !== "") {
            writer.uint32(18).string(message.city);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsCity();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.city = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsCountry() {
    return { encId: 0, country: "" };
}
exports.PlayerSetsCountry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.country !== "") {
            writer.uint32(18).string(message.country);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsCountry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.country = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsStartDate() {
    return { encId: 0, startDate: "" };
}
exports.PlayerSetsStartDate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.startDate !== "") {
            writer.uint32(18).string(message.startDate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsStartDate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.startDate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsTimezone() {
    return { encId: 0, timezone: "" };
}
exports.PlayerSetsTimezone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.timezone !== "") {
            writer.uint32(18).string(message.timezone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsTimezone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.timezone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsPhone() {
    return { encId: 0, phone: "" };
}
exports.PlayerSetsPhone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.phone !== "") {
            writer.uint32(18).string(message.phone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsPhone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.phone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsDescription() {
    return { encId: 0, description: "" };
}
exports.PlayerSetsDescription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsDescription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsProfileImageUrl() {
    return { encId: 0, profileImageUrl: "" };
}
exports.PlayerSetsProfileImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.profileImageUrl !== "") {
            writer.uint32(18).string(message.profileImageUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsProfileImageUrl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.profileImageUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsPersonalImageUrl() {
    return { encId: 0, personalImageUrl: "" };
}
exports.PlayerSetsPersonalImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.personalImageUrl !== "") {
            writer.uint32(18).string(message.personalImageUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsPersonalImageUrl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.personalImageUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsIsMobile() {
    return { encId: 0, isMobile: false };
}
exports.PlayerSetsIsMobile = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isMobile === true) {
            writer.uint32(16).bool(message.isMobile);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsIsMobile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isMobile = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsEmojiStatus() {
    return { encId: 0, emojiStatus: "" };
}
exports.PlayerSetsEmojiStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.emojiStatus !== "") {
            writer.uint32(18).string(message.emojiStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsEmojiStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.emojiStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsAffiliation() {
    return { encId: 0, affiliation: "" };
}
exports.PlayerSetsAffiliation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.affiliation !== "") {
            writer.uint32(18).string(message.affiliation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsAffiliation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.affiliation = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerExits() {
    return { encId: 0 };
}
exports.PlayerExits = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerExits();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsOutfitString() {
    return { encId: 0, outfitString: "" };
}
exports.PlayerSetsOutfitString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.outfitString !== "") {
            writer.uint32(18).string(message.outfitString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsOutfitString();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.outfitString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsIsSignedIn() {
    return { encId: 0, isSignedIn: false };
}
exports.PlayerSetsIsSignedIn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isSignedIn === true) {
            writer.uint32(16).bool(message.isSignedIn);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsIsSignedIn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isSignedIn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRespawnComplete() {
    return {};
}
exports.RespawnComplete = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRespawnComplete();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceOverwrites() {
    return { spaceData: "" };
}
exports.SpaceOverwrites = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spaceData !== "") {
            writer.uint32(10).string(message.spaceData);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceOverwrites();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spaceData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDynamicGate() {
    return { exposure: 0, spaces: [] };
}
exports.DynamicGate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exposure !== 0) {
            writer.uint32(13).float(message.exposure);
        }
        for (const v of message.spaces) {
            writer.uint32(18).string(v);
        }
        if (message.refreshOnChange !== undefined) {
            writer.uint32(24).bool(message.refreshOnChange);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDynamicGate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exposure = reader.float();
                    break;
                case 2:
                    message.spaces.push(reader.string());
                    break;
                case 3:
                    message.refreshOnChange = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDynamicGates() {
    return { livekitEnabled: undefined };
}
exports.DynamicGates = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.livekitEnabled !== undefined) {
            exports.DynamicGate.encode(message.livekitEnabled, writer.uint32(10).fork()).ldelim();
        }
        if (message.livekitSelfhostEnabled !== undefined) {
            exports.DynamicGate.encode(message.livekitSelfhostEnabled, writer.uint32(18).fork()).ldelim();
        }
        if (message.agoraEnabled !== undefined) {
            exports.DynamicGate.encode(message.agoraEnabled, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDynamicGates();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.livekitEnabled = exports.DynamicGate.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.livekitSelfhostEnabled = exports.DynamicGate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.agoraEnabled = exports.DynamicGate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceSetsSpaceMembers() {
    return { members: {} };
}
exports.SpaceSetsSpaceMembers = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.members).forEach(([key, value]) => {
            exports.SpaceSetsSpaceMembers_MembersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceSetsSpaceMembers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SpaceSetsSpaceMembers_MembersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.members[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceSetsSpaceMembers_MembersEntry() {
    return { key: "", value: undefined };
}
exports.SpaceSetsSpaceMembers_MembersEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.SpaceMemberInfo.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceSetsSpaceMembers_MembersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.SpaceMemberInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceIsClosed() {
    return {};
}
exports.SpaceIsClosed = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceIsClosed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerEntersPortal() {
    return { targetUrl: "" };
}
exports.PlayerEntersPortal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetUrl !== "") {
            writer.uint32(10).string(message.targetUrl);
        }
        if (message.bypassPrompt !== undefined) {
            writer.uint32(16).bool(message.bypassPrompt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerEntersPortal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetUrl = reader.string();
                    break;
                case 2:
                    message.bypassPrompt = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCookieFound() {
    return { encId: 0 };
}
exports.CookieFound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCookieFound();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceSetsIdMapping() {
    return { uid: "", encId: 0 };
}
exports.SpaceSetsIdMapping = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.uid !== "") {
            writer.uint32(10).string(message.uid);
        }
        if (message.encId !== 0) {
            writer.uint32(16).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceSetsIdMapping();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.uid = reader.string();
                    break;
                case 2:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerShootsConfetti() {
    return { encId: 0 };
}
exports.PlayerShootsConfetti = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerShootsConfetti();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsEventStatus() {
    return { encId: 0, eventStatus: "" };
}
exports.PlayerSetsEventStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.eventStatus !== "") {
            writer.uint32(18).string(message.eventStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsEventStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.eventStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsInConversation() {
    return { encId: 0, inConversation: false };
}
exports.PlayerSetsInConversation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.inConversation === true) {
            writer.uint32(16).bool(message.inConversation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsInConversation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.inConversation = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsCurrentDesk() {
    return { encId: 0, currentDesk: "" };
}
exports.PlayerSetsCurrentDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.currentDesk !== "") {
            writer.uint32(18).string(message.currentDesk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsCurrentDesk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.currentDesk = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsCurrentArea() {
    return { encId: 0, currentArea: "" };
}
exports.PlayerSetsCurrentArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.currentArea !== "") {
            writer.uint32(18).string(message.currentArea);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsCurrentArea();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.currentArea = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsGoKartId() {
    return { encId: 0, goKartId: "" };
}
exports.PlayerSetsGoKartId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.goKartId !== "") {
            writer.uint32(18).string(message.goKartId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsGoKartId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.goKartId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsVehicleId() {
    return { encId: 0, vehicleId: "", action: "", previousVehicleId: "" };
}
exports.PlayerSetsVehicleId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.vehicleId !== "") {
            writer.uint32(18).string(message.vehicleId);
        }
        if (message.action !== "") {
            writer.uint32(26).string(message.action);
        }
        if (message.previousVehicleId !== "") {
            writer.uint32(34).string(message.previousVehicleId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsVehicleId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.vehicleId = reader.string();
                    break;
                case 3:
                    message.action = reader.string();
                    break;
                case 4:
                    message.previousVehicleId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsSpeedModifier() {
    return { encId: 0, speedModifier: 0 };
}
exports.PlayerSetsSpeedModifier = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.speedModifier !== 0) {
            writer.uint32(21).float(message.speedModifier);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsSpeedModifier();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.speedModifier = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsIsAlone() {
    return { encId: 0, isAlone: false };
}
exports.PlayerSetsIsAlone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isAlone === true) {
            writer.uint32(16).bool(message.isAlone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsIsAlone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isAlone = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpacePlaysSound() {
    return { src: "", volume: 0 };
}
exports.SpacePlaysSound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(18).string(message.src);
        }
        if (message.volume !== 0) {
            writer.uint32(29).float(message.volume);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpacePlaysSound();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.src = reader.string();
                    break;
                case 3:
                    message.volume = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceStopsSound() {
    return { src: "" };
}
exports.SpaceStopsSound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(18).string(message.src);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceStopsSound();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.src = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsFocusModeEndTime() {
    return { encId: 0, focusModeEndTime: "" };
}
exports.PlayerSetsFocusModeEndTime = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.focusModeEndTime !== "") {
            writer.uint32(18).string(message.focusModeEndTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsFocusModeEndTime();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.focusModeEndTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerBlocks() {
    return { blockedBy: "", blocked: false };
}
exports.PlayerBlocks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockedBy !== "") {
            writer.uint32(10).string(message.blockedBy);
        }
        if (message.blocked === true) {
            writer.uint32(16).bool(message.blocked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerBlocks();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockedBy = reader.string();
                    break;
                case 2:
                    message.blocked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCustomEvent() {
    return { name: "", payload: "" };
}
exports.CustomEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.payload !== "") {
            writer.uint32(18).string(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.payload = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerUpdatesFocusModeStatus() {
    return { encId: 0, isInFocusMode: false };
}
exports.PlayerUpdatesFocusModeStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isInFocusMode === true) {
            writer.uint32(16).bool(message.isInFocusMode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerUpdatesFocusModeStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isInFocusMode = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsItemString() {
    return { encId: 0, itemString: "" };
}
exports.PlayerSetsItemString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.itemString !== "") {
            writer.uint32(18).string(message.itemString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsItemString();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.itemString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerTriggersItem() {
    return { encId: 0 };
}
exports.PlayerTriggersItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.closestObject !== undefined) {
            writer.uint32(18).string(message.closestObject);
        }
        if (message.closestObjectTemplate !== undefined) {
            writer.uint32(26).string(message.closestObjectTemplate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerTriggersItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.closestObject = reader.string();
                    break;
                case 3:
                    message.closestObjectTemplate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerNotifies() {
    return { encId: 0, notification: "" };
}
exports.PlayerNotifies = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.notification !== "") {
            writer.uint32(18).string(message.notification);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerNotifies();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.notification = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsFollowTarget() {
    return { encId: 0, followTarget: "" };
}
exports.PlayerSetsFollowTarget = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.followTarget !== "") {
            writer.uint32(18).string(message.followTarget);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsFollowTarget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.followTarget = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerRequestsToLead() {
    return { encId: 0, snapshot: "" };
}
exports.PlayerRequestsToLead = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.snapshot !== "") {
            writer.uint32(18).string(message.snapshot);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerRequestsToLead();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.snapshot = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsManualVideoSrc() {
    return { encId: 0, manualVideoSrc: "" };
}
exports.PlayerSetsManualVideoSrc = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.manualVideoSrc !== "") {
            writer.uint32(18).string(message.manualVideoSrc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsManualVideoSrc();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.manualVideoSrc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsIsNpc() {
    return { encId: 0, isNpc: false };
}
exports.PlayerSetsIsNpc = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isNpc === true) {
            writer.uint32(16).bool(message.isNpc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsIsNpc();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isNpc = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsSubtitle() {
    return { encId: 0, subtitle: "" };
}
exports.PlayerSetsSubtitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.subtitle !== "") {
            writer.uint32(18).string(message.subtitle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsSubtitle();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.subtitle = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerCrafts() {
    return { encId: 0, inputs: {} };
}
exports.PlayerCrafts = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        Object.entries(message.inputs).forEach(([key, value]) => {
            exports.PlayerCrafts_InputsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerCrafts();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    const entry2 = exports.PlayerCrafts_InputsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.inputs[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerCrafts_InputsEntry() {
    return { key: "", value: 0 };
}
exports.PlayerCrafts_InputsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).uint32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerCrafts_InputsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapMoveObject() {
    return { mapId: "", objectId: "", targetX: 0, targetY: 0, duration: 0 };
}
exports.MapMoveObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.objectId !== "") {
            writer.uint32(18).string(message.objectId);
        }
        if (message.targetX !== 0) {
            writer.uint32(29).float(message.targetX);
        }
        if (message.targetY !== 0) {
            writer.uint32(37).float(message.targetY);
        }
        if (message.targetXOffset !== undefined) {
            writer.uint32(45).float(message.targetXOffset);
        }
        if (message.targetYOffset !== undefined) {
            writer.uint32(53).float(message.targetYOffset);
        }
        if (message.duration !== 0) {
            writer.uint32(61).float(message.duration);
        }
        if (message.easing !== undefined) {
            writer.uint32(66).string(message.easing);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapMoveObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.objectId = reader.string();
                    break;
                case 3:
                    message.targetX = reader.float();
                    break;
                case 4:
                    message.targetY = reader.float();
                    break;
                case 5:
                    message.targetXOffset = reader.float();
                    break;
                case 6:
                    message.targetYOffset = reader.float();
                    break;
                case 7:
                    message.duration = reader.float();
                    break;
                case 8:
                    message.easing = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerEditsChatMessage() {
    return { id: "" };
}
exports.PlayerEditsChatMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.likes !== undefined) {
            writer.uint32(16).uint32(message.likes);
        }
        if (message.replied !== undefined) {
            writer.uint32(24).bool(message.replied);
        }
        if (message.reply !== undefined) {
            exports.ChatReply.encode(message.reply, writer.uint32(34).fork()).ldelim();
        }
        if (message.approved !== undefined) {
            writer.uint32(40).bool(message.approved);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerEditsChatMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.likes = reader.uint32();
                    break;
                case 3:
                    message.replied = reader.bool();
                    break;
                case 4:
                    message.reply = exports.ChatReply.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.approved = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseFXShakeObject() {
    return { mapId: "", targetId: "" };
}
exports.FXShakeObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.targetId !== "") {
            writer.uint32(18).string(message.targetId);
        }
        if (message.intensity !== undefined) {
            writer.uint32(29).float(message.intensity);
        }
        if (message.durationMs !== undefined) {
            writer.uint32(37).float(message.durationMs);
        }
        if (message.mode !== undefined) {
            writer.uint32(40).uint32(message.mode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFXShakeObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.intensity = reader.float();
                    break;
                case 4:
                    message.durationMs = reader.float();
                    break;
                case 5:
                    message.mode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseFXShakeCamera() {
    return {};
}
exports.FXShakeCamera = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.intensity !== undefined) {
            writer.uint32(13).float(message.intensity);
        }
        if (message.durationMs !== undefined) {
            writer.uint32(21).float(message.durationMs);
        }
        if (message.mapId !== undefined) {
            writer.uint32(26).string(message.mapId);
        }
        if (message.targetUserId !== undefined) {
            writer.uint32(34).string(message.targetUserId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFXShakeCamera();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.intensity = reader.float();
                    break;
                case 2:
                    message.durationMs = reader.float();
                    break;
                case 3:
                    message.mapId = reader.string();
                    break;
                case 4:
                    message.targetUserId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerHighFives() {
    return { encId: 0, encIdTarget: 0 };
}
exports.PlayerHighFives = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.encIdTarget !== 0) {
            writer.uint32(16).uint32(message.encIdTarget);
        }
        if (message.emote !== undefined) {
            writer.uint32(26).string(message.emote);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerHighFives();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.encIdTarget = reader.uint32();
                    break;
                case 3:
                    message.emote = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSendsCommand() {
    return { encId: 0, command: "" };
}
exports.PlayerSendsCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.command !== "") {
            writer.uint32(18).string(message.command);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSendsCommand();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceRegistersCommand() {
    return { command: "" };
}
exports.SpaceRegistersCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.command !== "") {
            writer.uint32(18).string(message.command);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceRegistersCommand();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerUpdatesInventory() {
    return { encId: 0, items: {}, order: {} };
}
exports.PlayerUpdatesInventory = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        Object.entries(message.items).forEach(([key, value]) => {
            exports.PlayerUpdatesInventory_ItemsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.order).forEach(([key, value]) => {
            exports.PlayerUpdatesInventory_OrderEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerUpdatesInventory();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    const entry2 = exports.PlayerUpdatesInventory_ItemsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.items[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    const entry3 = exports.PlayerUpdatesInventory_OrderEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.order[entry3.key] = entry3.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerUpdatesInventory_ItemsEntry() {
    return { key: "", value: undefined };
}
exports.PlayerUpdatesInventory_ItemsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.InventoryItem.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerUpdatesInventory_ItemsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.InventoryItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerUpdatesInventory_OrderEntry() {
    return { key: "", value: "" };
}
exports.PlayerUpdatesInventory_OrderEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerUpdatesInventory_OrderEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceUpdatesItems() {
    return { items: {} };
}
exports.SpaceUpdatesItems = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.items).forEach(([key, value]) => {
            exports.SpaceUpdatesItems_ItemsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceUpdatesItems();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SpaceUpdatesItems_ItemsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.items[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceUpdatesItems_ItemsEntry() {
    return { key: "", value: undefined };
}
exports.SpaceUpdatesItems_ItemsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.SpaceItem.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceUpdatesItems_ItemsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.SpaceItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerTriggersInventoryItem() {
    return { encId: 0, itemId: "", abilityId: "" };
}
exports.PlayerTriggersInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.itemId !== "") {
            writer.uint32(18).string(message.itemId);
        }
        if (message.abilityId !== "") {
            writer.uint32(26).string(message.abilityId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerTriggersInventoryItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.itemId = reader.string();
                    break;
                case 3:
                    message.abilityId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsAllowScreenPointer() {
    return { encId: 0, allowScreenPointer: false };
}
exports.PlayerSetsAllowScreenPointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.allowScreenPointer === true) {
            writer.uint32(16).bool(message.allowScreenPointer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsAllowScreenPointer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.allowScreenPointer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePrecomputedEnterLocation() {
    return { enterLocation: undefined };
}
exports.PrecomputedEnterLocation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.enterLocation !== undefined) {
            exports.MapLocation.encode(message.enterLocation, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrecomputedEnterLocation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enterLocation = exports.MapLocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsDeskInfo() {
    return { encId: 0, deskInfo: undefined };
}
exports.PlayerSetsDeskInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.deskInfo !== undefined) {
            exports.DeskInfoV2.encode(message.deskInfo, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsDeskInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.deskInfo = exports.DeskInfoV2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceSetsCapacity() {
    return { capacity: 0 };
}
exports.SpaceSetsCapacity = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.capacity !== 0) {
            writer.uint32(8).uint32(message.capacity);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceSetsCapacity();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.capacity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceOverCapacityDeniesUser() {
    return { userId: "" };
}
exports.SpaceOverCapacityDeniesUser = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceOverCapacityDeniesUser();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerSetsAway() {
    return { encId: 0, away: false };
}
exports.PlayerSetsAway = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.away === true) {
            writer.uint32(16).bool(message.away);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerSetsAway();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.away = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerStartsRecording() {
    return { encId: 0, nookId: "" };
}
exports.PlayerStartsRecording = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.nookId !== "") {
            writer.uint32(18).string(message.nookId);
        }
        if (message.initializing !== undefined) {
            writer.uint32(24).bool(message.initializing);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerStartsRecording();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.nookId = reader.string();
                    break;
                case 3:
                    message.initializing = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAccessRequest() {
    return { guestId: "", memberId: "", requestedAtUnixTime: 0, guestName: "", guestOutfitString: "" };
}
exports.AccessRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.guestId !== "") {
            writer.uint32(10).string(message.guestId);
        }
        if (message.memberId !== "") {
            writer.uint32(18).string(message.memberId);
        }
        if (message.requestedAtUnixTime !== 0) {
            writer.uint32(24).uint64(message.requestedAtUnixTime);
        }
        if (message.guestName !== "") {
            writer.uint32(34).string(message.guestName);
        }
        if (message.guestOutfitString !== "") {
            writer.uint32(42).string(message.guestOutfitString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccessRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.guestId = reader.string();
                    break;
                case 2:
                    message.memberId = reader.string();
                    break;
                case 3:
                    message.requestedAtUnixTime = longToNumber(reader.uint64());
                    break;
                case 4:
                    message.guestName = reader.string();
                    break;
                case 5:
                    message.guestOutfitString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAccessRequestsUpdated() {
    return { requests: [] };
}
exports.AccessRequestsUpdated = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.requests) {
            exports.AccessRequest.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccessRequestsUpdated();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requests.push(exports.AccessRequest.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAccessRequestRespondedTo() {
    return { targetId: "", accepted: false, location: undefined };
}
exports.AccessRequestRespondedTo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetId !== "") {
            writer.uint32(10).string(message.targetId);
        }
        if (message.accepted === true) {
            writer.uint32(16).bool(message.accepted);
        }
        if (message.location !== undefined) {
            exports.MapLocation.encode(message.location, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccessRequestRespondedTo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.accepted = reader.bool();
                    break;
                case 3:
                    message.location = exports.MapLocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerGuestPassStatus() {
    return { userId: "", guestPassStatus: "" };
}
exports.PlayerGuestPassStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.guestPassStatus !== "") {
            writer.uint32(18).string(message.guestPassStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerGuestPassStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.guestPassStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceSetsGuestPassStatuses() {
    return { playerGuestPassStatuses: [] };
}
exports.SpaceSetsGuestPassStatuses = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.playerGuestPassStatuses) {
            exports.PlayerGuestPassStatus.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceSetsGuestPassStatuses();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playerGuestPassStatuses.push(exports.PlayerGuestPassStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnterWithTeammatesSetOwnLobbyInfo() {
    return { name: "", outfitString: "" };
}
exports.EnterWithTeammatesSetOwnLobbyInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.outfitString !== "") {
            writer.uint32(18).string(message.outfitString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnterWithTeammatesSetOwnLobbyInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.outfitString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnterWithTeammatesInitiateEnterSpace() {
    return {};
}
exports.EnterWithTeammatesInitiateEnterSpace = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnterWithTeammatesInitiateEnterSpace();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetDeskFromNextAvailableDesk() {
    return { desksToIgnore: [] };
}
exports.SetDeskFromNextAvailableDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetId !== undefined) {
            writer.uint32(10).string(message.targetId);
        }
        if (message.preferredDesk !== undefined) {
            exports.MapAndDesk.encode(message.preferredDesk, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.desksToIgnore) {
            exports.MapAndDesk.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetDeskFromNextAvailableDesk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.preferredDesk = exports.MapAndDesk.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.desksToIgnore.push(exports.MapAndDesk.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpaceRolePermissionOverrideUpdated() {
    return { role: "", permission: "", enabled: false };
}
exports.SpaceRolePermissionOverrideUpdated = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.role !== "") {
            writer.uint32(10).string(message.role);
        }
        if (message.permission !== "") {
            writer.uint32(18).string(message.permission);
        }
        if (message.enabled === true) {
            writer.uint32(24).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpaceRolePermissionOverrideUpdated();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.role = reader.string();
                    break;
                case 2:
                    message.permission = reader.string();
                    break;
                case 3:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseClientServerBatch() {
    return { actions: [] };
}
exports.ClientServerBatch = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.actions) {
            exports.ClientServerAction.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientServerBatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(exports.ClientServerAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseClientServerAction() {
    return { action: undefined };
}
exports.ClientServerAction = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a;
        if (message.txnId !== undefined) {
            writer.uint32(800).uint32(message.txnId);
        }
        switch ((_a = message.action) === null || _a === void 0 ? void 0 : _a.$case) {
            case "clientHeartbeat":
                exports.ClientHeartbeat.encode(message.action.clientHeartbeat, writer.uint32(10).fork()).ldelim();
                break;
            case "clientBackupHeartbeat":
                exports.ClientBackupHeartbeat.encode(message.action.clientBackupHeartbeat, writer.uint32(18).fork()).ldelim();
                break;
            case "updateSubscriptions":
                exports.UpdateSubscriptions.encode(message.action.updateSubscriptions, writer.uint32(26).fork()).ldelim();
                break;
            case "move":
                exports.Move.encode(message.action.move, writer.uint32(42).fork()).ldelim();
                break;
            case "setAffiliation":
                exports.SetAffiliation.encode(message.action.setAffiliation, writer.uint32(58).fork()).ldelim();
                break;
            case "setStatus":
                exports.SetStatus.encode(message.action.setStatus, writer.uint32(66).fork()).ldelim();
                break;
            case "spotlight":
                exports.Spotlight.encode(message.action.spotlight, writer.uint32(74).fork()).ldelim();
                break;
            case "ring":
                exports.Ring.encode(message.action.ring, writer.uint32(82).fork()).ldelim();
                break;
            case "ban":
                exports.Ban.encode(message.action.ban, writer.uint32(98).fork()).ldelim();
                break;
            case "kick":
                exports.Kick.encode(message.action.kick, writer.uint32(106).fork()).ldelim();
                break;
            case "setImpassable":
                exports.SetImpassable.encode(message.action.setImpassable, writer.uint32(114).fork()).ldelim();
                break;
            case "chat":
                exports.Chat.encode(message.action.chat, writer.uint32(122).fork()).ldelim();
                break;
            case "interact":
                exports.Interact.encode(message.action.interact, writer.uint32(146).fork()).ldelim();
                break;
            case "enterWhisper":
                exports.EnterWhisper.encode(message.action.enterWhisper, writer.uint32(154).fork()).ldelim();
                break;
            case "leaveWhisper":
                exports.LeaveWhisper.encode(message.action.leaveWhisper, writer.uint32(162).fork()).ldelim();
                break;
            case "setEmojiStatus":
                exports.SetEmojiStatus.encode(message.action.setEmojiStatus, writer.uint32(170).fork()).ldelim();
                break;
            case "activelySpeaking":
                exports.ActivelySpeaking.encode(message.action.activelySpeaking, writer.uint32(178).fork()).ldelim();
                break;
            case "setName":
                exports.SetName.encode(message.action.setName, writer.uint32(194).fork()).ldelim();
                break;
            case "setTextStatus":
                exports.SetTextStatus.encode(message.action.setTextStatus, writer.uint32(202).fork()).ldelim();
                break;
            case "teleport":
                exports.Teleport.encode(message.action.teleport, writer.uint32(210).fork()).ldelim();
                break;
            case "exit":
                exports.Exit.encode(message.action.exit, writer.uint32(218).fork()).ldelim();
                break;
            case "enter":
                exports.Enter.encode(message.action.enter, writer.uint32(226).fork()).ldelim();
                break;
            case "setWorkCondition":
                exports.SetWorkCondition.encode(message.action.setWorkCondition, writer.uint32(234).fork()).ldelim();
                break;
            case "respawn":
                exports.Respawn.encode(message.action.respawn, writer.uint32(242).fork()).ldelim();
                break;
            case "spawn":
                exports.Spawn.encode(message.action.spawn, writer.uint32(250).fork()).ldelim();
                break;
            case "ghost":
                exports.Ghost.encode(message.action.ghost, writer.uint32(258).fork()).ldelim();
                break;
            case "init":
                exports.Init.encode(message.action.init, writer.uint32(266).fork()).ldelim();
                break;
            case "setOutfitString":
                exports.SetOutfitString.encode(message.action.setOutfitString, writer.uint32(274).fork()).ldelim();
                break;
            case "shootConfetti":
                exports.ShootConfetti.encode(message.action.shootConfetti, writer.uint32(290).fork()).ldelim();
                break;
            case "setEventStatus":
                exports.SetEventStatus.encode(message.action.setEventStatus, writer.uint32(298).fork()).ldelim();
                break;
            case "setInConversation":
                exports.SetInConversation.encode(message.action.setInConversation, writer.uint32(306).fork()).ldelim();
                break;
            case "setCurrentDesk":
                exports.SetCurrentDesk.encode(message.action.setCurrentDesk, writer.uint32(314).fork()).ldelim();
                break;
            case "setCurrentArea":
                exports.SetCurrentArea.encode(message.action.setCurrentArea, writer.uint32(322).fork()).ldelim();
                break;
            case "setImagePointer":
                exports.SetImagePointer.encode(message.action.setImagePointer, writer.uint32(330).fork()).ldelim();
                break;
            case "setGoKartId":
                exports.SetGoKartId.encode(message.action.setGoKartId, writer.uint32(338).fork()).ldelim();
                break;
            case "mapSetDimensions":
                exports.MapSetDimensions.encode(message.action.mapSetDimensions, writer.uint32(346).fork()).ldelim();
                break;
            case "mapSetCollisions":
                exports.MapSetCollisions.encode(message.action.mapSetCollisions, writer.uint32(354).fork()).ldelim();
                break;
            case "mapSetBackgroundImagePath":
                exports.MapSetBackgroundImagePath.encode(message.action.mapSetBackgroundImagePath, writer.uint32(362).fork()).ldelim();
                break;
            case "mapSetForegroundImagePath":
                exports.MapSetForegroundImagePath.encode(message.action.mapSetForegroundImagePath, writer.uint32(370).fork()).ldelim();
                break;
            case "mapSetSprites":
                exports.MapSetSprites.encode(message.action.mapSetSprites, writer.uint32(378).fork()).ldelim();
                break;
            case "mapSetSpawns":
                exports.MapSetSpawns.encode(message.action.mapSetSpawns, writer.uint32(386).fork()).ldelim();
                break;
            case "mapSetSpaces":
                exports.MapSetSpaces.encode(message.action.mapSetSpaces, writer.uint32(394).fork()).ldelim();
                break;
            case "mapSetPortals":
                exports.MapSetPortals.encode(message.action.mapSetPortals, writer.uint32(402).fork()).ldelim();
                break;
            case "mapSetAnnouncer":
                exports.MapSetAnnouncer.encode(message.action.mapSetAnnouncer, writer.uint32(410).fork()).ldelim();
                break;
            case "mapSetAssets":
                exports.MapSetAssets.encode(message.action.mapSetAssets, writer.uint32(434).fork()).ldelim();
                break;
            case "mapSetObjects":
                exports.MapSetObjects.encode(message.action.mapSetObjects, writer.uint32(442).fork()).ldelim();
                break;
            case "mapSetName":
                exports.MapSetName.encode(message.action.mapSetName, writer.uint32(450).fork()).ldelim();
                break;
            case "mapSetMuteOnEntry":
                exports.MapSetMuteOnEntry.encode(message.action.mapSetMuteOnEntry, writer.uint32(466).fork()).ldelim();
                break;
            case "mapSetUseDrawnBG":
                exports.MapSetUseDrawnBG.encode(message.action.mapSetUseDrawnBG, writer.uint32(474).fork()).ldelim();
                break;
            case "mapSetWalls":
                exports.MapSetWalls.encode(message.action.mapSetWalls, writer.uint32(482).fork()).ldelim();
                break;
            case "mapSetFloors":
                exports.MapSetFloors.encode(message.action.mapSetFloors, writer.uint32(490).fork()).ldelim();
                break;
            case "mapSetAreas":
                exports.MapSetAreas.encode(message.action.mapSetAreas, writer.uint32(498).fork()).ldelim();
                break;
            case "mapAddObject":
                exports.MapAddObject.encode(message.action.mapAddObject, writer.uint32(506).fork()).ldelim();
                break;
            case "mapDeleteObject":
                exports.MapDeleteObject.encode(message.action.mapDeleteObject, writer.uint32(514).fork()).ldelim();
                break;
            case "mapSetSpawn":
                exports.MapSetSpawn.encode(message.action.mapSetSpawn, writer.uint32(522).fork()).ldelim();
                break;
            case "setIsAlone":
                exports.SetIsAlone.encode(message.action.setIsAlone, writer.uint32(530).fork()).ldelim();
                break;
            case "mapSetMiniMapImagePath":
                exports.MapSetMiniMapImagePath.encode(message.action.mapSetMiniMapImagePath, writer.uint32(538).fork()).ldelim();
                break;
            case "mapSetEnabledChats":
                exports.MapSetEnabledChats.encode(message.action.mapSetEnabledChats, writer.uint32(546).fork()).ldelim();
                break;
            case "mapSetDescription":
                exports.MapSetDescription.encode(message.action.mapSetDescription, writer.uint32(554).fork()).ldelim();
                break;
            case "mapSetDecoration":
                exports.MapSetDecoration.encode(message.action.mapSetDecoration, writer.uint32(562).fork()).ldelim();
                break;
            case "mapSetTutorialTasks":
                exports.MapSetTutorialTasks.encode(message.action.mapSetTutorialTasks, writer.uint32(570).fork()).ldelim();
                break;
            case "playSound":
                exports.PlaySound.encode(message.action.playSound, writer.uint32(578).fork()).ldelim();
                break;
            case "mapSetScript":
                exports.MapSetScript.encode(message.action.mapSetScript, writer.uint32(586).fork()).ldelim();
                break;
            case "setIsMobile":
                exports.SetIsMobile.encode(message.action.setIsMobile, writer.uint32(602).fork()).ldelim();
                break;
            case "setScreenPointer":
                exports.SetScreenPointer.encode(message.action.setScreenPointer, writer.uint32(610).fork()).ldelim();
                break;
            case "setEmoteV2":
                exports.SetEmoteV2.encode(message.action.setEmoteV2, writer.uint32(618).fork()).ldelim();
                break;
            case "setFocusModeEndTime":
                exports.SetFocusModeEndTime.encode(message.action.setFocusModeEndTime, writer.uint32(626).fork()).ldelim();
                break;
            case "mapDeleteObjectById":
                exports.MapDeleteObjectById.encode(message.action.mapDeleteObjectById, writer.uint32(634).fork()).ldelim();
                break;
            case "customAction":
                exports.CustomAction.encode(message.action.customAction, writer.uint32(642).fork()).ldelim();
                break;
            case "block":
                exports.Block.encode(message.action.block, writer.uint32(658).fork()).ldelim();
                break;
            case "setItemString":
                exports.SetItemString.encode(message.action.setItemString, writer.uint32(666).fork()).ldelim();
                break;
            case "triggerItem":
                exports.TriggerItem.encode(message.action.triggerItem, writer.uint32(674).fork()).ldelim();
                break;
            case "notify":
                exports.Notify.encode(message.action.notify, writer.uint32(682).fork()).ldelim();
                break;
            case "setFollowTarget":
                exports.SetFollowTarget.encode(message.action.setFollowTarget, writer.uint32(690).fork()).ldelim();
                break;
            case "requestToLead":
                exports.RequestToLead.encode(message.action.requestToLead, writer.uint32(698).fork()).ldelim();
                break;
            case "enterPortal":
                exports.EnterPortal.encode(message.action.enterPortal, writer.uint32(706).fork()).ldelim();
                break;
            case "setManualVideoSrc":
                exports.SetManualVideoSrc.encode(message.action.setManualVideoSrc, writer.uint32(714).fork()).ldelim();
                break;
            case "setSubtitle":
                exports.SetSubtitle.encode(message.action.setSubtitle, writer.uint32(722).fork()).ldelim();
                break;
            case "playerUpdatesSession":
                exports.PlayerUpdatesSession.encode(message.action.playerUpdatesSession, writer.uint32(730).fork()).ldelim();
                break;
            case "mapMoveObject":
                exports.MapMoveObject.encode(message.action.mapMoveObject, writer.uint32(738).fork()).ldelim();
                break;
            case "chatMessageUpdated":
                exports.ChatMessageUpdated.encode(message.action.chatMessageUpdated, writer.uint32(746).fork()).ldelim();
                break;
            case "fxShakeObject":
                exports.FXShakeObject.encode(message.action.fxShakeObject, writer.uint32(754).fork()).ldelim();
                break;
            case "fxShakeCamera":
                exports.FXShakeCamera.encode(message.action.fxShakeCamera, writer.uint32(762).fork()).ldelim();
                break;
            case "registerCommand":
                exports.RegisterCommand.encode(message.action.registerCommand, writer.uint32(770).fork()).ldelim();
                break;
            case "sendCommand":
                exports.SendCommand.encode(message.action.sendCommand, writer.uint32(778).fork()).ldelim();
                break;
            case "speakerUpdatesSession":
                exports.SpeakerUpdatesSession.encode(message.action.speakerUpdatesSession, writer.uint32(786).fork()).ldelim();
                break;
            case "addInventoryItem":
                exports.AddInventoryItem.encode(message.action.addInventoryItem, writer.uint32(810).fork()).ldelim();
                break;
            case "removeInventoryItem":
                exports.RemoveInventoryItem.encode(message.action.removeInventoryItem, writer.uint32(818).fork()).ldelim();
                break;
            case "setVehicleId":
                exports.SetVehicleId.encode(message.action.setVehicleId, writer.uint32(826).fork()).ldelim();
                break;
            case "setSpeedModifier":
                exports.SetSpeedModifier.encode(message.action.setSpeedModifier, writer.uint32(834).fork()).ldelim();
                break;
            case "highFive":
                exports.HighFive.encode(message.action.highFive, writer.uint32(842).fork()).ldelim();
                break;
            case "updateSpaceItems":
                exports.SpaceUpdatesItems.encode(message.action.updateSpaceItems, writer.uint32(858).fork()).ldelim();
                break;
            case "stopSound":
                exports.StopSound.encode(message.action.stopSound, writer.uint32(866).fork()).ldelim();
                break;
            case "hipToBeSquare":
                exports.HipToBeSquare.encode(message.action.hipToBeSquare, writer.uint32(874).fork()).ldelim();
                break;
            case "craft":
                exports.Craft.encode(message.action.craft, writer.uint32(882).fork()).ldelim();
                break;
            case "triggerInventoryItem":
                exports.TriggerInventoryItem.encode(message.action.triggerInventoryItem, writer.uint32(890).fork()).ldelim();
                break;
            case "setAllowScreenPointer":
                exports.SetAllowScreenPointer.encode(message.action.setAllowScreenPointer, writer.uint32(898).fork()).ldelim();
                break;
            case "precomputeEnter":
                exports.PrecomputeEnter.encode(message.action.precomputeEnter, writer.uint32(906).fork()).ldelim();
                break;
            case "requestMute":
                exports.RequestMute.encode(message.action.requestMute, writer.uint32(914).fork()).ldelim();
                break;
            case "setDeskInfo":
                exports.SetDeskInfo.encode(message.action.setDeskInfo, writer.uint32(922).fork()).ldelim();
                break;
            case "mapSetNooks":
                exports.MapSetNooks.encode(message.action.mapSetNooks, writer.uint32(930).fork()).ldelim();
                break;
            case "requestToJoinNook":
                exports.RequestToJoinNook.encode(message.action.requestToJoinNook, writer.uint32(938).fork()).ldelim();
                break;
            case "updateNookPermission":
                exports.UpdateNookPermission.encode(message.action.updateNookPermission, writer.uint32(946).fork()).ldelim();
                break;
            case "wave":
                exports.Wave.encode(message.action.wave, writer.uint32(954).fork()).ldelim();
                break;
            case "setPronouns":
                exports.SetPronouns.encode(message.action.setPronouns, writer.uint32(962).fork()).ldelim();
                break;
            case "setTitle":
                exports.SetTitle.encode(message.action.setTitle, writer.uint32(970).fork()).ldelim();
                break;
            case "setTimezone":
                exports.SetTimezone.encode(message.action.setTimezone, writer.uint32(978).fork()).ldelim();
                break;
            case "setPhone":
                exports.SetPhone.encode(message.action.setPhone, writer.uint32(986).fork()).ldelim();
                break;
            case "setDescription":
                exports.SetDescription.encode(message.action.setDescription, writer.uint32(994).fork()).ldelim();
                break;
            case "setProfileImageUrl":
                exports.SetProfileImageUrl.encode(message.action.setProfileImageUrl, writer.uint32(1002).fork()).ldelim();
                break;
            case "setPersonalImageUrl":
                exports.SetPersonalImageUrl.encode(message.action.setPersonalImageUrl, writer.uint32(1010).fork()).ldelim();
                break;
            case "setAway":
                exports.SetAway.encode(message.action.setAway, writer.uint32(1018).fork()).ldelim();
                break;
            case "setCity":
                exports.SetCity.encode(message.action.setCity, writer.uint32(1026).fork()).ldelim();
                break;
            case "setCountry":
                exports.SetCountry.encode(message.action.setCountry, writer.uint32(1034).fork()).ldelim();
                break;
            case "setStartDate":
                exports.SetStartDate.encode(message.action.setStartDate, writer.uint32(1042).fork()).ldelim();
                break;
            case "startRecording":
                exports.StartRecording.encode(message.action.startRecording, writer.uint32(1050).fork()).ldelim();
                break;
            case "requestAccessViaCheckIn":
                exports.RequestAccessViaCheckIn.encode(message.action.requestAccessViaCheckIn, writer.uint32(1058).fork()).ldelim();
                break;
            case "respondToAccessRequest":
                exports.RespondToAccessRequest.encode(message.action.respondToAccessRequest, writer.uint32(1066).fork()).ldelim();
                break;
            case "setAvailability":
                exports.SetAvailability.encode(message.action.setAvailability, writer.uint32(1074).fork()).ldelim();
                break;
            case "enterWithTeammatesSetOwnLobbyInfo":
                exports.EnterWithTeammatesSetOwnLobbyInfo.encode(message.action.enterWithTeammatesSetOwnLobbyInfo, writer.uint32(1082).fork()).ldelim();
                break;
            case "enterWithTeammatesInitiateEnterSpace":
                exports.EnterWithTeammatesInitiateEnterSpace.encode(message.action.enterWithTeammatesInitiateEnterSpace, writer.uint32(1090).fork()).ldelim();
                break;
            case "respawnAtDesk":
                exports.RespawnAtDesk.encode(message.action.respawnAtDesk, writer.uint32(1098).fork()).ldelim();
                break;
            case "setDeskFromNextAvailableDesk":
                exports.SetDeskFromNextAvailableDesk.encode(message.action.setDeskFromNextAvailableDesk, writer.uint32(1106).fork())
                    .ldelim();
                break;
            case "setSpaceRolePermissionOverride":
                exports.SetSpaceRolePermissionOverride.encode(message.action.setSpaceRolePermissionOverride, writer.uint32(1114).fork())
                    .ldelim();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientServerAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 100:
                    message.txnId = reader.uint32();
                    break;
                case 1:
                    message.action = {
                        $case: "clientHeartbeat",
                        clientHeartbeat: exports.ClientHeartbeat.decode(reader, reader.uint32()),
                    };
                    break;
                case 2:
                    message.action = {
                        $case: "clientBackupHeartbeat",
                        clientBackupHeartbeat: exports.ClientBackupHeartbeat.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.action = {
                        $case: "updateSubscriptions",
                        updateSubscriptions: exports.UpdateSubscriptions.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.action = { $case: "move", move: exports.Move.decode(reader, reader.uint32()) };
                    break;
                case 7:
                    message.action = { $case: "setAffiliation", setAffiliation: exports.SetAffiliation.decode(reader, reader.uint32()) };
                    break;
                case 8:
                    message.action = { $case: "setStatus", setStatus: exports.SetStatus.decode(reader, reader.uint32()) };
                    break;
                case 9:
                    message.action = { $case: "spotlight", spotlight: exports.Spotlight.decode(reader, reader.uint32()) };
                    break;
                case 10:
                    message.action = { $case: "ring", ring: exports.Ring.decode(reader, reader.uint32()) };
                    break;
                case 12:
                    message.action = { $case: "ban", ban: exports.Ban.decode(reader, reader.uint32()) };
                    break;
                case 13:
                    message.action = { $case: "kick", kick: exports.Kick.decode(reader, reader.uint32()) };
                    break;
                case 14:
                    message.action = { $case: "setImpassable", setImpassable: exports.SetImpassable.decode(reader, reader.uint32()) };
                    break;
                case 15:
                    message.action = { $case: "chat", chat: exports.Chat.decode(reader, reader.uint32()) };
                    break;
                case 18:
                    message.action = { $case: "interact", interact: exports.Interact.decode(reader, reader.uint32()) };
                    break;
                case 19:
                    message.action = { $case: "enterWhisper", enterWhisper: exports.EnterWhisper.decode(reader, reader.uint32()) };
                    break;
                case 20:
                    message.action = { $case: "leaveWhisper", leaveWhisper: exports.LeaveWhisper.decode(reader, reader.uint32()) };
                    break;
                case 21:
                    message.action = { $case: "setEmojiStatus", setEmojiStatus: exports.SetEmojiStatus.decode(reader, reader.uint32()) };
                    break;
                case 22:
                    message.action = {
                        $case: "activelySpeaking",
                        activelySpeaking: exports.ActivelySpeaking.decode(reader, reader.uint32()),
                    };
                    break;
                case 24:
                    message.action = { $case: "setName", setName: exports.SetName.decode(reader, reader.uint32()) };
                    break;
                case 25:
                    message.action = { $case: "setTextStatus", setTextStatus: exports.SetTextStatus.decode(reader, reader.uint32()) };
                    break;
                case 26:
                    message.action = { $case: "teleport", teleport: exports.Teleport.decode(reader, reader.uint32()) };
                    break;
                case 27:
                    message.action = { $case: "exit", exit: exports.Exit.decode(reader, reader.uint32()) };
                    break;
                case 28:
                    message.action = { $case: "enter", enter: exports.Enter.decode(reader, reader.uint32()) };
                    break;
                case 29:
                    message.action = {
                        $case: "setWorkCondition",
                        setWorkCondition: exports.SetWorkCondition.decode(reader, reader.uint32()),
                    };
                    break;
                case 30:
                    message.action = { $case: "respawn", respawn: exports.Respawn.decode(reader, reader.uint32()) };
                    break;
                case 31:
                    message.action = { $case: "spawn", spawn: exports.Spawn.decode(reader, reader.uint32()) };
                    break;
                case 32:
                    message.action = { $case: "ghost", ghost: exports.Ghost.decode(reader, reader.uint32()) };
                    break;
                case 33:
                    message.action = { $case: "init", init: exports.Init.decode(reader, reader.uint32()) };
                    break;
                case 34:
                    message.action = {
                        $case: "setOutfitString",
                        setOutfitString: exports.SetOutfitString.decode(reader, reader.uint32()),
                    };
                    break;
                case 36:
                    message.action = { $case: "shootConfetti", shootConfetti: exports.ShootConfetti.decode(reader, reader.uint32()) };
                    break;
                case 37:
                    message.action = { $case: "setEventStatus", setEventStatus: exports.SetEventStatus.decode(reader, reader.uint32()) };
                    break;
                case 38:
                    message.action = {
                        $case: "setInConversation",
                        setInConversation: exports.SetInConversation.decode(reader, reader.uint32()),
                    };
                    break;
                case 39:
                    message.action = { $case: "setCurrentDesk", setCurrentDesk: exports.SetCurrentDesk.decode(reader, reader.uint32()) };
                    break;
                case 40:
                    message.action = { $case: "setCurrentArea", setCurrentArea: exports.SetCurrentArea.decode(reader, reader.uint32()) };
                    break;
                case 41:
                    message.action = {
                        $case: "setImagePointer",
                        setImagePointer: exports.SetImagePointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 42:
                    message.action = { $case: "setGoKartId", setGoKartId: exports.SetGoKartId.decode(reader, reader.uint32()) };
                    break;
                case 43:
                    message.action = {
                        $case: "mapSetDimensions",
                        mapSetDimensions: exports.MapSetDimensions.decode(reader, reader.uint32()),
                    };
                    break;
                case 44:
                    message.action = {
                        $case: "mapSetCollisions",
                        mapSetCollisions: exports.MapSetCollisions.decode(reader, reader.uint32()),
                    };
                    break;
                case 45:
                    message.action = {
                        $case: "mapSetBackgroundImagePath",
                        mapSetBackgroundImagePath: exports.MapSetBackgroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 46:
                    message.action = {
                        $case: "mapSetForegroundImagePath",
                        mapSetForegroundImagePath: exports.MapSetForegroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 47:
                    message.action = { $case: "mapSetSprites", mapSetSprites: exports.MapSetSprites.decode(reader, reader.uint32()) };
                    break;
                case 48:
                    message.action = { $case: "mapSetSpawns", mapSetSpawns: exports.MapSetSpawns.decode(reader, reader.uint32()) };
                    break;
                case 49:
                    message.action = { $case: "mapSetSpaces", mapSetSpaces: exports.MapSetSpaces.decode(reader, reader.uint32()) };
                    break;
                case 50:
                    message.action = { $case: "mapSetPortals", mapSetPortals: exports.MapSetPortals.decode(reader, reader.uint32()) };
                    break;
                case 51:
                    message.action = {
                        $case: "mapSetAnnouncer",
                        mapSetAnnouncer: exports.MapSetAnnouncer.decode(reader, reader.uint32()),
                    };
                    break;
                case 54:
                    message.action = { $case: "mapSetAssets", mapSetAssets: exports.MapSetAssets.decode(reader, reader.uint32()) };
                    break;
                case 55:
                    message.action = { $case: "mapSetObjects", mapSetObjects: exports.MapSetObjects.decode(reader, reader.uint32()) };
                    break;
                case 56:
                    message.action = { $case: "mapSetName", mapSetName: exports.MapSetName.decode(reader, reader.uint32()) };
                    break;
                case 58:
                    message.action = {
                        $case: "mapSetMuteOnEntry",
                        mapSetMuteOnEntry: exports.MapSetMuteOnEntry.decode(reader, reader.uint32()),
                    };
                    break;
                case 59:
                    message.action = {
                        $case: "mapSetUseDrawnBG",
                        mapSetUseDrawnBG: exports.MapSetUseDrawnBG.decode(reader, reader.uint32()),
                    };
                    break;
                case 60:
                    message.action = { $case: "mapSetWalls", mapSetWalls: exports.MapSetWalls.decode(reader, reader.uint32()) };
                    break;
                case 61:
                    message.action = { $case: "mapSetFloors", mapSetFloors: exports.MapSetFloors.decode(reader, reader.uint32()) };
                    break;
                case 62:
                    message.action = { $case: "mapSetAreas", mapSetAreas: exports.MapSetAreas.decode(reader, reader.uint32()) };
                    break;
                case 63:
                    message.action = { $case: "mapAddObject", mapAddObject: exports.MapAddObject.decode(reader, reader.uint32()) };
                    break;
                case 64:
                    message.action = {
                        $case: "mapDeleteObject",
                        mapDeleteObject: exports.MapDeleteObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 65:
                    message.action = { $case: "mapSetSpawn", mapSetSpawn: exports.MapSetSpawn.decode(reader, reader.uint32()) };
                    break;
                case 66:
                    message.action = { $case: "setIsAlone", setIsAlone: exports.SetIsAlone.decode(reader, reader.uint32()) };
                    break;
                case 67:
                    message.action = {
                        $case: "mapSetMiniMapImagePath",
                        mapSetMiniMapImagePath: exports.MapSetMiniMapImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 68:
                    message.action = {
                        $case: "mapSetEnabledChats",
                        mapSetEnabledChats: exports.MapSetEnabledChats.decode(reader, reader.uint32()),
                    };
                    break;
                case 69:
                    message.action = {
                        $case: "mapSetDescription",
                        mapSetDescription: exports.MapSetDescription.decode(reader, reader.uint32()),
                    };
                    break;
                case 70:
                    message.action = {
                        $case: "mapSetDecoration",
                        mapSetDecoration: exports.MapSetDecoration.decode(reader, reader.uint32()),
                    };
                    break;
                case 71:
                    message.action = {
                        $case: "mapSetTutorialTasks",
                        mapSetTutorialTasks: exports.MapSetTutorialTasks.decode(reader, reader.uint32()),
                    };
                    break;
                case 72:
                    message.action = { $case: "playSound", playSound: exports.PlaySound.decode(reader, reader.uint32()) };
                    break;
                case 73:
                    message.action = { $case: "mapSetScript", mapSetScript: exports.MapSetScript.decode(reader, reader.uint32()) };
                    break;
                case 75:
                    message.action = { $case: "setIsMobile", setIsMobile: exports.SetIsMobile.decode(reader, reader.uint32()) };
                    break;
                case 76:
                    message.action = {
                        $case: "setScreenPointer",
                        setScreenPointer: exports.SetScreenPointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 77:
                    message.action = { $case: "setEmoteV2", setEmoteV2: exports.SetEmoteV2.decode(reader, reader.uint32()) };
                    break;
                case 78:
                    message.action = {
                        $case: "setFocusModeEndTime",
                        setFocusModeEndTime: exports.SetFocusModeEndTime.decode(reader, reader.uint32()),
                    };
                    break;
                case 79:
                    message.action = {
                        $case: "mapDeleteObjectById",
                        mapDeleteObjectById: exports.MapDeleteObjectById.decode(reader, reader.uint32()),
                    };
                    break;
                case 80:
                    message.action = { $case: "customAction", customAction: exports.CustomAction.decode(reader, reader.uint32()) };
                    break;
                case 82:
                    message.action = { $case: "block", block: exports.Block.decode(reader, reader.uint32()) };
                    break;
                case 83:
                    message.action = { $case: "setItemString", setItemString: exports.SetItemString.decode(reader, reader.uint32()) };
                    break;
                case 84:
                    message.action = { $case: "triggerItem", triggerItem: exports.TriggerItem.decode(reader, reader.uint32()) };
                    break;
                case 85:
                    message.action = { $case: "notify", notify: exports.Notify.decode(reader, reader.uint32()) };
                    break;
                case 86:
                    message.action = {
                        $case: "setFollowTarget",
                        setFollowTarget: exports.SetFollowTarget.decode(reader, reader.uint32()),
                    };
                    break;
                case 87:
                    message.action = { $case: "requestToLead", requestToLead: exports.RequestToLead.decode(reader, reader.uint32()) };
                    break;
                case 88:
                    message.action = { $case: "enterPortal", enterPortal: exports.EnterPortal.decode(reader, reader.uint32()) };
                    break;
                case 89:
                    message.action = {
                        $case: "setManualVideoSrc",
                        setManualVideoSrc: exports.SetManualVideoSrc.decode(reader, reader.uint32()),
                    };
                    break;
                case 90:
                    message.action = { $case: "setSubtitle", setSubtitle: exports.SetSubtitle.decode(reader, reader.uint32()) };
                    break;
                case 91:
                    message.action = {
                        $case: "playerUpdatesSession",
                        playerUpdatesSession: exports.PlayerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 92:
                    message.action = { $case: "mapMoveObject", mapMoveObject: exports.MapMoveObject.decode(reader, reader.uint32()) };
                    break;
                case 93:
                    message.action = {
                        $case: "chatMessageUpdated",
                        chatMessageUpdated: exports.ChatMessageUpdated.decode(reader, reader.uint32()),
                    };
                    break;
                case 94:
                    message.action = { $case: "fxShakeObject", fxShakeObject: exports.FXShakeObject.decode(reader, reader.uint32()) };
                    break;
                case 95:
                    message.action = { $case: "fxShakeCamera", fxShakeCamera: exports.FXShakeCamera.decode(reader, reader.uint32()) };
                    break;
                case 96:
                    message.action = {
                        $case: "registerCommand",
                        registerCommand: exports.RegisterCommand.decode(reader, reader.uint32()),
                    };
                    break;
                case 97:
                    message.action = { $case: "sendCommand", sendCommand: exports.SendCommand.decode(reader, reader.uint32()) };
                    break;
                case 98:
                    message.action = {
                        $case: "speakerUpdatesSession",
                        speakerUpdatesSession: exports.SpeakerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 101:
                    message.action = {
                        $case: "addInventoryItem",
                        addInventoryItem: exports.AddInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 102:
                    message.action = {
                        $case: "removeInventoryItem",
                        removeInventoryItem: exports.RemoveInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 103:
                    message.action = { $case: "setVehicleId", setVehicleId: exports.SetVehicleId.decode(reader, reader.uint32()) };
                    break;
                case 104:
                    message.action = {
                        $case: "setSpeedModifier",
                        setSpeedModifier: exports.SetSpeedModifier.decode(reader, reader.uint32()),
                    };
                    break;
                case 105:
                    message.action = { $case: "highFive", highFive: exports.HighFive.decode(reader, reader.uint32()) };
                    break;
                case 107:
                    message.action = {
                        $case: "updateSpaceItems",
                        updateSpaceItems: exports.SpaceUpdatesItems.decode(reader, reader.uint32()),
                    };
                    break;
                case 108:
                    message.action = { $case: "stopSound", stopSound: exports.StopSound.decode(reader, reader.uint32()) };
                    break;
                case 109:
                    message.action = { $case: "hipToBeSquare", hipToBeSquare: exports.HipToBeSquare.decode(reader, reader.uint32()) };
                    break;
                case 110:
                    message.action = { $case: "craft", craft: exports.Craft.decode(reader, reader.uint32()) };
                    break;
                case 111:
                    message.action = {
                        $case: "triggerInventoryItem",
                        triggerInventoryItem: exports.TriggerInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 112:
                    message.action = {
                        $case: "setAllowScreenPointer",
                        setAllowScreenPointer: exports.SetAllowScreenPointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 113:
                    message.action = {
                        $case: "precomputeEnter",
                        precomputeEnter: exports.PrecomputeEnter.decode(reader, reader.uint32()),
                    };
                    break;
                case 114:
                    message.action = { $case: "requestMute", requestMute: exports.RequestMute.decode(reader, reader.uint32()) };
                    break;
                case 115:
                    message.action = { $case: "setDeskInfo", setDeskInfo: exports.SetDeskInfo.decode(reader, reader.uint32()) };
                    break;
                case 116:
                    message.action = { $case: "mapSetNooks", mapSetNooks: exports.MapSetNooks.decode(reader, reader.uint32()) };
                    break;
                case 117:
                    message.action = {
                        $case: "requestToJoinNook",
                        requestToJoinNook: exports.RequestToJoinNook.decode(reader, reader.uint32()),
                    };
                    break;
                case 118:
                    message.action = {
                        $case: "updateNookPermission",
                        updateNookPermission: exports.UpdateNookPermission.decode(reader, reader.uint32()),
                    };
                    break;
                case 119:
                    message.action = { $case: "wave", wave: exports.Wave.decode(reader, reader.uint32()) };
                    break;
                case 120:
                    message.action = { $case: "setPronouns", setPronouns: exports.SetPronouns.decode(reader, reader.uint32()) };
                    break;
                case 121:
                    message.action = { $case: "setTitle", setTitle: exports.SetTitle.decode(reader, reader.uint32()) };
                    break;
                case 122:
                    message.action = { $case: "setTimezone", setTimezone: exports.SetTimezone.decode(reader, reader.uint32()) };
                    break;
                case 123:
                    message.action = { $case: "setPhone", setPhone: exports.SetPhone.decode(reader, reader.uint32()) };
                    break;
                case 124:
                    message.action = { $case: "setDescription", setDescription: exports.SetDescription.decode(reader, reader.uint32()) };
                    break;
                case 125:
                    message.action = {
                        $case: "setProfileImageUrl",
                        setProfileImageUrl: exports.SetProfileImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 126:
                    message.action = {
                        $case: "setPersonalImageUrl",
                        setPersonalImageUrl: exports.SetPersonalImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 127:
                    message.action = { $case: "setAway", setAway: exports.SetAway.decode(reader, reader.uint32()) };
                    break;
                case 128:
                    message.action = { $case: "setCity", setCity: exports.SetCity.decode(reader, reader.uint32()) };
                    break;
                case 129:
                    message.action = { $case: "setCountry", setCountry: exports.SetCountry.decode(reader, reader.uint32()) };
                    break;
                case 130:
                    message.action = { $case: "setStartDate", setStartDate: exports.SetStartDate.decode(reader, reader.uint32()) };
                    break;
                case 131:
                    message.action = { $case: "startRecording", startRecording: exports.StartRecording.decode(reader, reader.uint32()) };
                    break;
                case 132:
                    message.action = {
                        $case: "requestAccessViaCheckIn",
                        requestAccessViaCheckIn: exports.RequestAccessViaCheckIn.decode(reader, reader.uint32()),
                    };
                    break;
                case 133:
                    message.action = {
                        $case: "respondToAccessRequest",
                        respondToAccessRequest: exports.RespondToAccessRequest.decode(reader, reader.uint32()),
                    };
                    break;
                case 134:
                    message.action = {
                        $case: "setAvailability",
                        setAvailability: exports.SetAvailability.decode(reader, reader.uint32()),
                    };
                    break;
                case 135:
                    message.action = {
                        $case: "enterWithTeammatesSetOwnLobbyInfo",
                        enterWithTeammatesSetOwnLobbyInfo: exports.EnterWithTeammatesSetOwnLobbyInfo.decode(reader, reader.uint32()),
                    };
                    break;
                case 136:
                    message.action = {
                        $case: "enterWithTeammatesInitiateEnterSpace",
                        enterWithTeammatesInitiateEnterSpace: exports.EnterWithTeammatesInitiateEnterSpace.decode(reader, reader.uint32()),
                    };
                    break;
                case 137:
                    message.action = { $case: "respawnAtDesk", respawnAtDesk: exports.RespawnAtDesk.decode(reader, reader.uint32()) };
                    break;
                case 138:
                    message.action = {
                        $case: "setDeskFromNextAvailableDesk",
                        setDeskFromNextAvailableDesk: exports.SetDeskFromNextAvailableDesk.decode(reader, reader.uint32()),
                    };
                    break;
                case 139:
                    message.action = {
                        $case: "setSpaceRolePermissionOverride",
                        setSpaceRolePermissionOverride: exports.SetSpaceRolePermissionOverride.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseClientHeartbeat() {
    return {};
}
exports.ClientHeartbeat = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientHeartbeat();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseClientBackupHeartbeat() {
    return {};
}
exports.ClientBackupHeartbeat = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientBackupHeartbeat();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseUpdateSubscriptions() {
    return { subscriptions: {}, mapUpdateIds: {} };
}
exports.UpdateSubscriptions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.subscriptions).forEach(([key, value]) => {
            exports.UpdateSubscriptions_SubscriptionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        Object.entries(message.mapUpdateIds).forEach(([key, value]) => {
            exports.UpdateSubscriptions_MapUpdateIdsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateSubscriptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.UpdateSubscriptions_SubscriptionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.subscriptions[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    const entry2 = exports.UpdateSubscriptions_MapUpdateIdsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.mapUpdateIds[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseUpdateSubscriptions_SubscriptionsEntry() {
    return { key: "", value: false };
}
exports.UpdateSubscriptions_SubscriptionsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value === true) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateSubscriptions_SubscriptionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseUpdateSubscriptions_MapUpdateIdsEntry() {
    return { key: "", value: 0 };
}
exports.UpdateSubscriptions_MapUpdateIdsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).uint64(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateSubscriptions_MapUpdateIdsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMove() {
    return { dir: 0, stopped: false, inputId: 0 };
}
exports.Move = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.dir !== 0) {
            writer.uint32(8).int32(message.dir);
        }
        if (message.stopped === true) {
            writer.uint32(16).bool(message.stopped);
        }
        if (message.inputId !== 0) {
            writer.uint32(24).uint32(message.inputId);
        }
        if (message.targetId !== undefined) {
            writer.uint32(34).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMove();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dir = reader.int32();
                    break;
                case 2:
                    message.stopped = reader.bool();
                    break;
                case 3:
                    message.inputId = reader.uint32();
                    break;
                case 4:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRequestMute() {
    return { target: "", video: false };
}
exports.RequestMute = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.target !== "") {
            writer.uint32(10).string(message.target);
        }
        if (message.video === true) {
            writer.uint32(16).bool(message.video);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestMute();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.target = reader.string();
                    break;
                case 2:
                    message.video = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetAffiliation() {
    return { affiliation: "" };
}
exports.SetAffiliation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.affiliation !== "") {
            writer.uint32(10).string(message.affiliation);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetAffiliation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.affiliation = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetStatus() {
    return { status: false };
}
exports.SetStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status === true) {
            writer.uint32(8).bool(message.status);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetAvailability() {
    return { availability: "" };
}
exports.SetAvailability = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.availability !== "") {
            writer.uint32(10).string(message.availability);
        }
        if (message.endOption !== undefined) {
            writer.uint32(18).string(message.endOption);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetAvailability();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.availability = reader.string();
                    break;
                case 2:
                    message.endOption = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetOutfitString() {
    return { outfitString: "" };
}
exports.SetOutfitString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.outfitString !== "") {
            writer.uint32(10).string(message.outfitString);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetOutfitString();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.outfitString = reader.string();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpotlight() {
    return { spotlightedUser: "", isSpotlighted: false };
}
exports.Spotlight = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spotlightedUser !== "") {
            writer.uint32(10).string(message.spotlightedUser);
        }
        if (message.isSpotlighted === true) {
            writer.uint32(16).bool(message.isSpotlighted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpotlight();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spotlightedUser = reader.string();
                    break;
                case 2:
                    message.isSpotlighted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRing() {
    return { user: "" };
}
exports.Ring = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRing();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetImagePointer() {
    return { objectId: "", x: 0, y: 0 };
}
exports.SetImagePointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.objectId !== "") {
            writer.uint32(10).string(message.objectId);
        }
        if (message.x !== 0) {
            writer.uint32(17).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(25).double(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetImagePointer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.objectId = reader.string();
                    break;
                case 2:
                    message.x = reader.double();
                    break;
                case 3:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetScreenPointer() {
    return { screenId: "", x: 0, y: 0 };
}
exports.SetScreenPointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.screenId !== "") {
            writer.uint32(10).string(message.screenId);
        }
        if (message.x !== 0) {
            writer.uint32(17).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(25).double(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetScreenPointer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.screenId = reader.string();
                    break;
                case 2:
                    message.x = reader.double();
                    break;
                case 3:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseBan() {
    return { user: "" };
}
exports.Ban = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBan();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseKick() {
    return { user: "" };
}
exports.Kick = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKick();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseBlock() {
    return { blockedUserId: "", blocked: false };
}
exports.Block = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockedUserId !== "") {
            writer.uint32(10).string(message.blockedUserId);
        }
        if (message.blocked === true) {
            writer.uint32(16).bool(message.blocked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockedUserId = reader.string();
                    break;
                case 2:
                    message.blocked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetImpassable() {
    return { mapId: "", x: 0, y: 0, impassable: false };
}
exports.SetImpassable = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.impassable === true) {
            writer.uint32(32).bool(message.impassable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetImpassable();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.impassable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseChat() {
    return { chatRecipient: "", contents: "", localPlayerIds: [], mapId: "" };
}
exports.Chat = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chatRecipient !== "") {
            writer.uint32(10).string(message.chatRecipient);
        }
        if (message.contents !== "") {
            writer.uint32(18).string(message.contents);
        }
        for (const v of message.localPlayerIds) {
            writer.uint32(26).string(v);
        }
        if (message.mapId !== "") {
            writer.uint32(34).string(message.mapId);
        }
        if (message.id !== undefined) {
            writer.uint32(42).string(message.id);
        }
        if (message.nookId !== undefined) {
            writer.uint32(50).string(message.nookId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChat();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chatRecipient = reader.string();
                    break;
                case 2:
                    message.contents = reader.string();
                    break;
                case 3:
                    message.localPlayerIds.push(reader.string());
                    break;
                case 4:
                    message.mapId = reader.string();
                    break;
                case 5:
                    message.id = reader.string();
                    break;
                case 6:
                    message.nookId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseNotify() {
    return { notification: "" };
}
exports.Notify = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.notification !== "") {
            writer.uint32(10).string(message.notification);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNotify();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.notification = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInteract() {
    return { objId: "" };
}
exports.Interact = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.objId !== "") {
            writer.uint32(10).string(message.objId);
        }
        if (message.mapId !== undefined) {
            writer.uint32(26).string(message.mapId);
        }
        if (message.dataJson !== undefined) {
            writer.uint32(18).string(message.dataJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInteract();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.objId = reader.string();
                    break;
                case 3:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.dataJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseActivelySpeaking() {
    return { activelySpeaking: false };
}
exports.ActivelySpeaking = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.activelySpeaking === true) {
            writer.uint32(8).bool(message.activelySpeaking);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActivelySpeaking();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.activelySpeaking = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnterWhisper() {
    return { recipientId: "", dir: 0 };
}
exports.EnterWhisper = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.recipientId !== "") {
            writer.uint32(10).string(message.recipientId);
        }
        if (message.dir !== 0) {
            writer.uint32(16).int32(message.dir);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnterWhisper();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.recipientId = reader.string();
                    break;
                case 2:
                    message.dir = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseLeaveWhisper() {
    return {};
}
exports.LeaveWhisper = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLeaveWhisper();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseGhost() {
    return { ghost: 0 };
}
exports.Ghost = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ghost !== 0) {
            writer.uint32(8).uint32(message.ghost);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGhost();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ghost = reader.uint32();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetEmoteV2() {
    return {};
}
exports.SetEmoteV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.emote !== undefined) {
            writer.uint32(10).string(message.emote);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        if (message.count !== undefined) {
            writer.uint32(24).uint32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetEmoteV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.emote = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetName() {
    return { name: "" };
}
exports.SetName = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetName();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetTextStatus() {
    return { textStatus: "" };
}
exports.SetTextStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.textStatus !== "") {
            writer.uint32(10).string(message.textStatus);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetTextStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.textStatus = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetPronouns() {
    return { pronouns: "" };
}
exports.SetPronouns = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pronouns !== "") {
            writer.uint32(10).string(message.pronouns);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetPronouns();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pronouns = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetTitle() {
    return { title: "" };
}
exports.SetTitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetTitle();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetCity() {
    return { city: "" };
}
exports.SetCity = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.city !== "") {
            writer.uint32(10).string(message.city);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetCity();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.city = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetCountry() {
    return { country: "" };
}
exports.SetCountry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.country !== "") {
            writer.uint32(10).string(message.country);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetCountry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.country = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetStartDate() {
    return { startDate: "" };
}
exports.SetStartDate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.startDate !== "") {
            writer.uint32(10).string(message.startDate);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetStartDate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.startDate = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetTimezone() {
    return { timezone: "" };
}
exports.SetTimezone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.timezone !== "") {
            writer.uint32(10).string(message.timezone);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetTimezone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.timezone = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetPhone() {
    return { phone: "" };
}
exports.SetPhone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.phone !== "") {
            writer.uint32(10).string(message.phone);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetPhone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetDescription() {
    return { description: "" };
}
exports.SetDescription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetDescription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetProfileImageUrl() {
    return { profileImageUrl: "" };
}
exports.SetProfileImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.profileImageUrl !== "") {
            writer.uint32(10).string(message.profileImageUrl);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetProfileImageUrl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.profileImageUrl = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetPersonalImageUrl() {
    return { personalImageUrl: "" };
}
exports.SetPersonalImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.personalImageUrl !== "") {
            writer.uint32(10).string(message.personalImageUrl);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetPersonalImageUrl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.personalImageUrl = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExit() {
    return {};
}
exports.Exit = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnter() {
    return {};
}
exports.Enter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.info !== undefined) {
            exports.PlayerInitInfo.encode(message.info, writer.uint32(10).fork()).ldelim();
        }
        if (message.spawnToken !== undefined) {
            writer.uint32(18).string(message.spawnToken);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.info = exports.PlayerInitInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.spawnToken = reader.string();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePrecomputeEnter() {
    return {};
}
exports.PrecomputeEnter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.enterLocation !== undefined) {
            exports.MapLocation.encode(message.enterLocation, writer.uint32(10).fork()).ldelim();
        }
        if (message.spawnToken !== undefined) {
            writer.uint32(18).string(message.spawnToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrecomputeEnter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enterLocation = exports.MapLocation.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.spawnToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetEmojiStatus() {
    return { emojiStatus: "" };
}
exports.SetEmojiStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.emojiStatus !== "") {
            writer.uint32(10).string(message.emojiStatus);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetEmojiStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.emojiStatus = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTeleport() {
    return { mapId: "", x: 0, y: 0 };
}
exports.Teleport = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.targetId !== undefined) {
            writer.uint32(34).string(message.targetId);
        }
        if (message.direction !== undefined) {
            writer.uint32(40).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTeleport();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.targetId = reader.string();
                    break;
                case 5:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetWorkCondition() {
    return { workCondition: false };
}
exports.SetWorkCondition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.workCondition === true) {
            writer.uint32(8).bool(message.workCondition);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetWorkCondition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.workCondition = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpawn() {
    return { spawnToken: "" };
}
exports.Spawn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spawnToken !== "") {
            writer.uint32(10).string(message.spawnToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpawn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spawnToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRespawn() {
    return {};
}
exports.Respawn = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRespawn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRespawnAtDesk() {
    return {};
}
exports.RespawnAtDesk = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRespawnAtDesk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRequestToJoinNook() {
    return { nookId: "", mapId: "" };
}
exports.RequestToJoinNook = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nookId !== "") {
            writer.uint32(10).string(message.nookId);
        }
        if (message.mapId !== "") {
            writer.uint32(18).string(message.mapId);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestToJoinNook();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nookId = reader.string();
                    break;
                case 2:
                    message.mapId = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseUpdateNookPermission() {
    return { playerId: "", nookId: "", granted: false };
}
exports.UpdateNookPermission = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.playerId !== "") {
            writer.uint32(10).string(message.playerId);
        }
        if (message.nookId !== "") {
            writer.uint32(18).string(message.nookId);
        }
        if (message.granted === true) {
            writer.uint32(24).bool(message.granted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateNookPermission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playerId = reader.string();
                    break;
                case 2:
                    message.nookId = reader.string();
                    break;
                case 3:
                    message.granted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInit() {
    return { spaceId: "", auth: undefined };
}
exports.Init = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a;
        if (message.spaceId !== "") {
            writer.uint32(10).string(message.spaceId);
        }
        switch ((_a = message.auth) === null || _a === void 0 ? void 0 : _a.$case) {
            case "token":
                writer.uint32(18).string(message.auth.token);
                break;
            case "apiKey":
                writer.uint32(26).string(message.auth.apiKey);
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spaceId = reader.string();
                    break;
                case 2:
                    message.auth = { $case: "token", token: reader.string() };
                    break;
                case 3:
                    message.auth = { $case: "apiKey", apiKey: reader.string() };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapAddObject() {
    return { mapId: "", object: undefined };
}
exports.MapAddObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.object !== undefined) {
            exports.WireObject.encode(message.object, writer.uint32(18).fork()).ldelim();
        }
        if (message.objectIdToPrependTo !== undefined) {
            writer.uint32(26).string(message.objectIdToPrependTo);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapAddObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.object = exports.WireObject.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.objectIdToPrependTo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseShootConfetti() {
    return {};
}
exports.ShootConfetti = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetId !== undefined) {
            writer.uint32(10).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShootConfetti();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetEventStatus() {
    return { eventStatus: "" };
}
exports.SetEventStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.eventStatus !== "") {
            writer.uint32(10).string(message.eventStatus);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetEventStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventStatus = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetInConversation() {
    return { inConversation: false };
}
exports.SetInConversation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inConversation === true) {
            writer.uint32(8).bool(message.inConversation);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetInConversation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.inConversation = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetCurrentDesk() {
    return { currentDesk: "" };
}
exports.SetCurrentDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.currentDesk !== "") {
            writer.uint32(10).string(message.currentDesk);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetCurrentDesk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currentDesk = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetCurrentArea() {
    return { currentArea: "" };
}
exports.SetCurrentArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.currentArea !== "") {
            writer.uint32(10).string(message.currentArea);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetCurrentArea();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currentArea = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetGoKartId() {
    return { goKartId: "" };
}
exports.SetGoKartId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.goKartId !== "") {
            writer.uint32(10).string(message.goKartId);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetGoKartId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.goKartId = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetVehicleId() {
    return { vehicleId: "" };
}
exports.SetVehicleId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.vehicleId !== "") {
            writer.uint32(10).string(message.vehicleId);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        if (message.action !== undefined) {
            writer.uint32(26).string(message.action);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetVehicleId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vehicleId = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.action = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetSpeedModifier() {
    return { speedModifier: 0 };
}
exports.SetSpeedModifier = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.speedModifier !== 0) {
            writer.uint32(13).float(message.speedModifier);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSpeedModifier();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.speedModifier = reader.float();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetIsAlone() {
    return { isAlone: false };
}
exports.SetIsAlone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isAlone === true) {
            writer.uint32(8).bool(message.isAlone);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetIsAlone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isAlone = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetIsMobile() {
    return { isMobile: false };
}
exports.SetIsMobile = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isMobile === true) {
            writer.uint32(8).bool(message.isMobile);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetIsMobile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isMobile = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaySound() {
    return { src: "", volume: 0 };
}
exports.PlaySound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.volume !== 0) {
            writer.uint32(21).float(message.volume);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaySound();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 2:
                    message.volume = reader.float();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseStopSound() {
    return { src: "" };
}
exports.StopSound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStopSound();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetFocusModeEndTime() {
    return { focusModeEndTime: "" };
}
exports.SetFocusModeEndTime = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.focusModeEndTime !== "") {
            writer.uint32(10).string(message.focusModeEndTime);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetFocusModeEndTime();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.focusModeEndTime = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetItemString() {
    return { itemString: "" };
}
exports.SetItemString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemString !== "") {
            writer.uint32(10).string(message.itemString);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetItemString();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemString = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTriggerItem() {
    return {};
}
exports.TriggerItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.closestObject !== undefined) {
            writer.uint32(10).string(message.closestObject);
        }
        if (message.closestObjectTemplate !== undefined) {
            writer.uint32(26).string(message.closestObjectTemplate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTriggerItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.closestObject = reader.string();
                    break;
                case 3:
                    message.closestObjectTemplate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCustomAction() {
    return { name: "", payload: "", recipients: [] };
}
exports.CustomAction = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.payload !== "") {
            writer.uint32(18).string(message.payload);
        }
        for (const v of message.recipients) {
            writer.uint32(26).string(v);
        }
        if (message.sendToAll !== undefined) {
            writer.uint32(32).bool(message.sendToAll);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.payload = reader.string();
                    break;
                case 3:
                    message.recipients.push(reader.string());
                    break;
                case 4:
                    message.sendToAll = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetFollowTarget() {
    return { followTarget: "" };
}
exports.SetFollowTarget = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.followTarget !== "") {
            writer.uint32(10).string(message.followTarget);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetFollowTarget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.followTarget = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRequestToLead() {
    return { target: "", snapshot: "" };
}
exports.RequestToLead = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.target !== "") {
            writer.uint32(10).string(message.target);
        }
        if (message.snapshot !== "") {
            writer.uint32(18).string(message.snapshot);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestToLead();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.target = reader.string();
                    break;
                case 2:
                    message.snapshot = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnterPortal() {
    return { targetUrl: "" };
}
exports.EnterPortal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetUrl !== "") {
            writer.uint32(10).string(message.targetUrl);
        }
        if (message.bypassPrompt !== undefined) {
            writer.uint32(16).bool(message.bypassPrompt);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnterPortal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetUrl = reader.string();
                    break;
                case 2:
                    message.bypassPrompt = reader.bool();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetManualVideoSrc() {
    return { manualVideoSrc: "" };
}
exports.SetManualVideoSrc = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.manualVideoSrc !== "") {
            writer.uint32(10).string(message.manualVideoSrc);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetManualVideoSrc();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.manualVideoSrc = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetSubtitle() {
    return { subtitle: "" };
}
exports.SetSubtitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.subtitle !== "") {
            writer.uint32(10).string(message.subtitle);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSubtitle();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subtitle = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapCommitsChanges() {
    return { mapId: "", updateId: 0 };
}
exports.MapCommitsChanges = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.updateId !== 0) {
            writer.uint32(16).uint64(message.updateId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapCommitsChanges();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.updateId = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlayerUpdatesSession() {
    return { roomId: "" };
}
exports.PlayerUpdatesSession = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.roomChecked !== undefined) {
            writer.uint32(8).bool(message.roomChecked);
        }
        if (message.chatChecked !== undefined) {
            writer.uint32(16).bool(message.chatChecked);
        }
        if (message.qaChecked !== undefined) {
            writer.uint32(24).bool(message.qaChecked);
        }
        if (message.approveQuestionsChecked !== undefined) {
            writer.uint32(32).bool(message.approveQuestionsChecked);
        }
        if (message.roomId !== "") {
            writer.uint32(42).string(message.roomId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayerUpdatesSession();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.roomChecked = reader.bool();
                    break;
                case 2:
                    message.chatChecked = reader.bool();
                    break;
                case 3:
                    message.qaChecked = reader.bool();
                    break;
                case 4:
                    message.approveQuestionsChecked = reader.bool();
                    break;
                case 5:
                    message.roomId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSpeakerUpdatesSession() {
    return { sessionId: "" };
}
exports.SpeakerUpdatesSession = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sessionId !== "") {
            writer.uint32(10).string(message.sessionId);
        }
        if (message.customizeRoomEnabled !== undefined) {
            writer.uint32(16).bool(message.customizeRoomEnabled);
        }
        if (message.chatEnabled !== undefined) {
            writer.uint32(24).bool(message.chatEnabled);
        }
        if (message.qaEnabled !== undefined) {
            writer.uint32(32).bool(message.qaEnabled);
        }
        if (message.approveQuestionsEnabled !== undefined) {
            writer.uint32(40).bool(message.approveQuestionsEnabled);
        }
        if (message.massMuteEnabled !== undefined) {
            writer.uint32(48).bool(message.massMuteEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpeakerUpdatesSession();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sessionId = reader.string();
                    break;
                case 2:
                    message.customizeRoomEnabled = reader.bool();
                    break;
                case 3:
                    message.chatEnabled = reader.bool();
                    break;
                case 4:
                    message.qaEnabled = reader.bool();
                    break;
                case 5:
                    message.approveQuestionsEnabled = reader.bool();
                    break;
                case 6:
                    message.massMuteEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseChatReply() {
    return { senderId: "", senderName: "", contents: "" };
}
exports.ChatReply = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.senderId !== "") {
            writer.uint32(10).string(message.senderId);
        }
        if (message.senderName !== "") {
            writer.uint32(18).string(message.senderName);
        }
        if (message.contents !== "") {
            writer.uint32(26).string(message.contents);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChatReply();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.senderId = reader.string();
                    break;
                case 2:
                    message.senderName = reader.string();
                    break;
                case 3:
                    message.contents = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseChatMessageUpdated() {
    return { id: "" };
}
exports.ChatMessageUpdated = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChatMessageUpdated();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSendCommand() {
    return { command: "" };
}
exports.SendCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.command !== "") {
            writer.uint32(10).string(message.command);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendCommand();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRegisterCommand() {
    return { command: "" };
}
exports.RegisterCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.command !== "") {
            writer.uint32(10).string(message.command);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterCommand();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCraft() {
    return { inputs: {} };
}
exports.Craft = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.inputs).forEach(([key, value]) => {
            exports.Craft_InputsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCraft();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.Craft_InputsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.inputs[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCraft_InputsEntry() {
    return { key: "", value: 0 };
}
exports.Craft_InputsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCraft_InputsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseHighFive() {
    return { targetId: "" };
}
exports.HighFive = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetId !== "") {
            writer.uint32(10).string(message.targetId);
        }
        if (message.emote !== undefined) {
            writer.uint32(18).string(message.emote);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHighFive();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.emote = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAddInventoryItem() {
    return { itemId: "", delta: 0, targetId: "" };
}
exports.AddInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        if (message.delta !== 0) {
            writer.uint32(16).uint64(message.delta);
        }
        if (message.targetId !== "") {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddInventoryItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                case 2:
                    message.delta = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRemoveInventoryItem() {
    return { itemId: "", delta: 0 };
}
exports.RemoveInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        if (message.delta !== 0) {
            writer.uint32(16).uint64(message.delta);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveInventoryItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                case 2:
                    message.delta = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseHipToBeSquare() {
    return { data: "" };
}
exports.HipToBeSquare = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data !== "") {
            writer.uint32(10).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHipToBeSquare();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTriggerInventoryItem() {
    return { itemId: "", abilityId: "" };
}
exports.TriggerInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        if (message.abilityId !== "") {
            writer.uint32(18).string(message.abilityId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTriggerInventoryItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                case 2:
                    message.abilityId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetAllowScreenPointer() {
    return { allowScreenPointer: false };
}
exports.SetAllowScreenPointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.allowScreenPointer === true) {
            writer.uint32(8).bool(message.allowScreenPointer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetAllowScreenPointer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.allowScreenPointer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetDeskInfo() {
    return { deskInfo: undefined };
}
exports.SetDeskInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deskInfo !== undefined) {
            exports.DeskInfoV2.encode(message.deskInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetDeskInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.deskInfo = exports.DeskInfoV2.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseWave() {
    return { user: "", isReply: false };
}
exports.Wave = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        if (message.isReply === true) {
            writer.uint32(16).bool(message.isReply);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWave();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                case 2:
                    message.isReply = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetAway() {
    return { away: false };
}
exports.SetAway = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.away === true) {
            writer.uint32(8).bool(message.away);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetAway();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.away = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseStartRecording() {
    return { nookId: "" };
}
exports.StartRecording = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nookId !== "") {
            writer.uint32(10).string(message.nookId);
        }
        if (message.initializing !== undefined) {
            writer.uint32(16).bool(message.initializing);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartRecording();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nookId = reader.string();
                    break;
                case 2:
                    message.initializing = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRequestAccessViaCheckIn() {
    return { userId: "", canceled: false };
}
exports.RequestAccessViaCheckIn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.canceled === true) {
            writer.uint32(16).bool(message.canceled);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        if (message.outfitString !== undefined) {
            writer.uint32(34).string(message.outfitString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestAccessViaCheckIn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.canceled = reader.bool();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.outfitString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRespondToAccessRequest() {
    return { userId: "", accepted: false };
}
exports.RespondToAccessRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.accepted === true) {
            writer.uint32(16).bool(message.accepted);
        }
        if (message.locationType !== undefined) {
            writer.uint32(24).int32(message.locationType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRespondToAccessRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.accepted = reader.bool();
                    break;
                case 3:
                    message.locationType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSetSpaceRolePermissionOverride() {
    return { role: "", permission: "", enabled: false };
}
exports.SetSpaceRolePermissionOverride = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.role !== "") {
            writer.uint32(10).string(message.role);
        }
        if (message.permission !== "") {
            writer.uint32(18).string(message.permission);
        }
        if (message.enabled === true) {
            writer.uint32(24).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSpaceRolePermissionOverride();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.role = reader.string();
                    break;
                case 2:
                    message.permission = reader.string();
                    break;
                case 3:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
exports.protobufWriterLibrary = minimal_1.default;
//# sourceMappingURL=events.js.map