// adapted from: https://stackoverflow.com/a/6573119/7343159

// never change this file.
// should be able to delete it after NGN-300

const _Rixits =
  //   0       8       16      24      32      40      48      56     63
  //   v       v       v       v       v       v       v       v      v
  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
// This cannot handle negative numbers and only works on the
//     integer part, discarding the fractional part.
// Doing better means deciding on whether you're just representing
// the subset of javascript numbers of twos-complement 32-bit integers
// or going with base-64 representations for the bit pattern of the
// underlying IEEE floating-point number, or representing the mantissae
// and exponents separately, or some other possibility. For now, bail
export const numToBase64 = (number: number): string => {
  if (isNaN(Number(number)) || number === null || number === Number.POSITIVE_INFINITY) {
    throw "The input is not valid";
  }
  if (number < 0) {
    throw "Can't represent negative numbers now";
  }

  let rixit; // like 'digit', only in some non-decimal radix
  let residual = Math.floor(number);
  let result = "";
  do {
    rixit = residual % 64;
    result = _Rixits.charAt(rixit) + result;
    residual = Math.floor(residual / 64);
  } while (residual !== 0);

  return result;
};

export const base64StringToNum = (rixits: string): number => {
  let result = 0;
  const rixitsList = rixits.split("");
  for (let e = 0; e < rixitsList.length; e++) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    result = result * 64 + _Rixits.indexOf(rixitsList[e]!);
  }
  return result;
};

/* some tests */
// console.log(base64StringToNum("Ajj"));
// console.log(numToBase64(43885));
// console.log(numToBase64(888));
// console.log(base64StringToNum("Du"));
// console.log(numToBase64(0));
// console.log(base64StringToNum("0"));
